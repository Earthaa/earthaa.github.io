<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo配置</title>
      <link href="/2019/09/21/hexo%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/09/21/hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>利用GitHub page的功能可以十分方便的设计出一个美观的个人博客，我的一些非CS的同学都有，这篇文章大概用来记录一些配置过程中踩到的坑，以后，如果有需要会逐步扩展，网上内容七零八碎，我在这里做个整合，供日后查阅，并且就权当刚建好blog的一次试水博文</p><h2 id="2、hexo建站"><a href="#2、hexo建站" class="headerlink" title="2、hexo建站"></a>2、hexo建站</h2><p>在mac中配置hexo其实十分方便，几行命令，选个主题就可以完成基本的建站、配置等操作。<br>以下是一些建站用到的命令，根据官网要求，首先确保有安装node.js且版本不低于8.6</p><p>安装hexo命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>建站命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> cd &lt;folder&gt;</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure></p><p>新建完成后，指定文件夹目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><p>其中_config.yml用来设置配置文件，source里面的_posts用来保存所写博文，详细的配置方法和hexo结构，可参考官网说明: <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>主题选择因人而异，我自己采用next的主题，这是GitHub上star最多的一款主题，功能齐全，界面优雅，可扩展性高，且依然在维护更新，这是<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">github链接</a>，此外 <a href="https://hexo.io/theme" target="_blank" rel="noopener">https://hexo.io/theme</a> 上也提供了许多主题，根据文档直接配置即可不再多言，本文下面主要记录些配置next时遇到的一些坑和解决策略</p><h2 id="3、添加公式渲染"><a href="#3、添加公式渲染" class="headerlink" title="3、添加公式渲染"></a>3、添加公式渲染</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>hexo原生的引擎是不支持LaTeX的数学公式的，这导致如果需要写一些用到公式的博文只能用图片代替，很不友好，一个比较好的解决方案是将原生的marked渲染引擎改为kramed渲染引擎，后者支持mathjax公式输出，mathjax是一款前端显示公式的插件，配置代码如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>安装完毕后，打开 /node_modules/hexo-renderer-kramed/lib/renderer.js，修改其中的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把上面这段改为下面</span></span><br><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>然后，修改hexo的math包，改为mathjax:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>修改mathjax的配置文件: /node_modules/hexo-renderer-mathjax/mathjax.html，将最后的\<script\> 标签改为如下的格式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></script\></p><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>更改默认转义规则，这是由于markdown本身的语法会与LaTeX公式语法相冲突，打开 /node_modules\kramed\lib\rules\inline.js，修改escape，em两个转移规则如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>对于next主题，主题配置文件_config.yml中要设置(此点很重要，网上教程许多有遗漏，会导致无法渲染):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">    enable: true</span><br><span class="line">mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></p><p>效果可以检查下，以下代码为显示薛定谔方程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$ i\hbar\frac&#123;\partial \psi&#125;&#123;\partial t&#125;</span><br><span class="line">= \frac&#123;-\hbar^2&#125;&#123;2m&#125; \left(</span><br><span class="line">\frac&#123;\partial^2&#125;&#123;\partial x^2&#125;</span><br><span class="line">+ \frac&#123;\partial^2&#125;&#123;\partial y^2&#125;</span><br><span class="line">+ \frac&#123;\partial^2&#125;&#123;\partial z^2&#125;</span><br><span class="line">\right) \psi + V \psi.$$</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><script type="math/tex; mode=display">i\hbar\frac{\partial \psi}{\partial t}= \frac{-\hbar^2}{2m} \left(\frac{\partial^2}{\partial x^2}+ \frac{\partial^2}{\partial y^2}+ \frac{\partial^2}{\partial z^2}\right) \psi + V \psi.</script><p>其实这个结果并不是重点，如何定位发现无法显示公式是引擎渲染问题，定位转义匹配问题，并且解决它们的过程才是重点，这也是程序员能力之所在</p><h2 id="4、添加本站搜索引擎"><a href="#4、添加本站搜索引擎" class="headerlink" title="4、添加本站搜索引擎"></a>4、添加本站搜索引擎</h2><p>这个网上有许多教程，不过对于next值得注意的是，searchdb包会导致产生的search.xml文件中的title包含类似CDATA这样的标签，理论上CDATA会被XML解析器忽略，但最后搜索时CDATA会莫名其妙地出现在搜索结果之中，所以建议采用search包，安装命令如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-generator-search</span><br></pre></td></tr></table></figure></p><p>完了直接修改站点配置文件_config.yml即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></table></figure></p><p>当然搜索引擎还有一些细节，例如修改field可修改引擎覆盖范围等等，可参考对应文档</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP信息的表示与处理</title>
      <link href="/2019/09/20/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <url>/2019/09/20/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对CMU 15213第一部分，信息的表示与处理的一个个人笔记和总结，主要包括计算机内整数的表示和浮点数的表示。</p><p>众所周知，计算机里对数字的表示方式是用二进制，显然，这与人类的习惯和直觉并不相符，根据Professor Bryant上课的说法，最早的计算机的确有人尝试过十进制，但后来发现，如果采用十进制表示数字，只能使用模拟信号处理，而模拟信号并不如数字信号准确和稳定，于是人们逐渐抛弃了其他进制的表示方法，而采用二进制。</p><p>值得一提的是，上个世纪70、80年代，苏联有科学家研究过三进制的计算机，半导体元器件有+1、0、-1三种形态，可以表示三进制，但是后来随着资金的撤出，三进制计算机流产。</p><h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><h3 id="无符号数（unsigned-number）"><a href="#无符号数（unsigned-number）" class="headerlink" title="无符号数（unsigned number）"></a>无符号数（unsigned number）</h3><p>通常的计算机中，用多位二进制码来表示一个整数（通常为32位或者64位），而其中如果最高位不用作符号位，则该表示方法为unsigned，c语言中就有unsigned int，unsigned char等等数据形式。</p><p>unsigned数的一般表示范围为: </p><p>$a+b=c$</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 符号数 </tag>
            
            <tag> 无符号数 </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode763 Partition Labels</title>
      <link href="/2019/09/20/LeetCode763-Partition-Labels/"/>
      <url>/2019/09/20/LeetCode763-Partition-Labels/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ababcbacadefegdehijhklij&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: [9,7,8]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>根据题意，我们是要将一个字符串划分为若干个区间，任何单个的字符都只能出现在一个区间内，通过简单的模拟题意，很容易发现，这是一个可以利用贪心得以解决的问题。</p><p>先扫一遍字符串，求出每个字符开始位置和终止位置。在第二次扫描时，每次向后读取一个字符，更新最大终止位置，求出区间长度，当扫描的index到达当前最大终止位置，则说明这段区间所有的字符都出现且仅出现在该区间内，此时保存位置即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)</span><br><span class="line">        last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">        j = Math.max(j, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            res.add(i - anchor + <span class="number">1</span>);</span><br><span class="line">            anchor = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>如果需要对英文或者数字字符进行hash，可以直接使用数组，不必从头再建立一个HashMap</li><li>本题曾出现在Amazon OA中</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Greedy </tag>
            
            <tag> Algorithms </tag>
            
            <tag> Amazon </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
